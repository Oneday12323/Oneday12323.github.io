---
title: 游戏离线包的存储管理与更新机制详解
tags: 离线包, DDD包, 存储治理, 版本更新
article_header:
  type: cover
excerpt_separator: <!--more-->
---

## 前言

在移动游戏开发中，离线包（也称为DDD包 - Dynamic Delivery Data）的管理是一个关键技术点。本文将深入探讨游戏离线包的存储治理、清理机制、更新策略，以及如何在版本迭代中保证资源的有效管理。

## 一、什么是DDD包（动态下发包）

### 1.1 定义与作用

**DDD包**是指由服务端动态下发到客户端的资源包，主要特点包括：

- **按需加载**：不随安装包一起发布，而是在需要时才下载
- **支持热更新**：可以在不发布新版本的情况下更新游戏内容
- **灵活管理**：支持活动资源、新关卡、新玩法等的快速上线
- **节省安装包体积**：将大量资源从安装包中分离出来

### 1.2 存储治理机制

游戏的DDD包通常采用**LRU（Least Recently Used）清理策略**来管理存储空间：

**触发条件：**
- 超过设定的天数未访问（如7天）
- 超过磁盘配额限制
- 存储空间不足时

**清理后果：**
```
DDD包被删除 → 对应的缓存也会被清除
下次访问时 → 需要重新下载资源包
```

## 二、离线包 vs 本地包

理解这两种包的区别对于制定合理的资源管理策略至关重要。

### 2.1 本地包（Local Package）

**定义：**
随App安装包一起发布的资源文件。

**特点：**
- **存储位置**：App的安装目录
- **获取方式**：随App安装自动部署
- **生命周期**：与App同生共死，不受清理策略影响
- **更新方式**：只能通过发布新版本App来更新
- **体积影响**：会增加安装包大小

**适用场景：**
- 游戏引擎核心文件
- 启动必需的基础资源
- 首屏UI和加载页
- 不常变动的公共资源

### 2.2 离线包（Offline Package）

**定义：**
预先下载到本地缓存的资源包，可在无网络状态下使用。

**特点：**
- **存储位置**：App的缓存目录
- **获取方式**：首次启动或特定时机下载
- **生命周期**：受存储治理策略影响，可能被LRU清理
- **更新方式**：可独立于App版本进行更新
- **体积影响**：不计入安装包大小

**适用场景：**
- 游戏关卡资源
- 活动相关内容
- 高频更新的业务逻辑
- 大体积媒体资源（音频、视频）

### 2.3 核心区别对比

| 特性 | 本地包 | 离线包 |
|------|--------|--------|
| 获取方式 | 随安装包 | 后续下载 |
| 存储位置 | 安装目录 | 缓存目录 |
| 是否可清理 | 否 | 是（受LRU等策略影响） |
| 更新频率 | 低（需发版） | 高（可独立更新） |
| 网络依赖 | 不需要 | 首次需要 |
| 安装包影响 | 增加体积 | 不影响 |
| 适用资源 | 核心基础资源 | 可变业务资源 |

## 三、离线包的存储位置与清理机制

### 3.1 存储位置详解

离线包存储在**App的私有存储空间**，不同平台的具体位置：

**iOS平台：**
```
/var/mobile/Containers/Data/Application/{APP_UUID}/
├── Library/Caches/offline_packages/    # 常用位置
│   ├── main_game_v1.2.0/
│   ├── activity_202411/
│   └── audio_pack/
├── Library/Application Support/        # 核心包可选位置
└── Documents/                          # 会被备份，不建议
```

**Android平台：**
```
/data/data/{package_name}/
├── cache/offline_packages/             # 常用位置
│   ├── main_game_v1.2.0/
│   └── subpackages/
└── files/packages/                     # 核心包位置

或外部存储：
/sdcard/Android/data/{package_name}/cache/
```

**关键要点：**
- 离线包存储在磁盘文件系统，不会因为杀掉进程而丢失
- 存储在`cache`目录可被系统在空间不足时清理
- 存储在`files`目录更安全，但占用"App大小"

### 3.2 清理机制深度解析

#### 3.2.1 不会因杀进程而清理

```
杀掉App进程 ≠ 清理离线包

原因：
- 离线包是持久化到磁盘的文件
- 杀进程只清理内存中的运行状态
- 文件系统中的资源依然存在
```

#### 3.2.2 App自身的LRU清理策略

**实现原理：**

```javascript
// 离线包管理器伪代码
class OfflinePackageManager {
    constructor() {
        this.maxCacheSize = 500 * 1024 * 1024; // 500MB配额
        this.maxAge = 7 * 24 * 60 * 60 * 1000; // 7天过期
    }
    
    // 定期清理检查（App启动时或定时任务）
    async cleanup() {
        const packages = await this.getAllPackages();
        const now = Date.now();
        
        // 1. 按最后访问时间排序
        packages.sort((a, b) => a.lastAccessTime - b.lastAccessTime);
        
        // 2. 清理过期包
        for (const pkg of packages) {
            if (now - pkg.lastAccessTime > this.maxAge) {
                await this.deletePackage(pkg.id);
            }
        }
        
        // 3. 清理超出配额的包（LRU策略）
        let totalSize = this.getTotalSize();
        let index = 0;
        while (totalSize > this.maxCacheSize && index < packages.length) {
            const pkg = packages[index];
            if (!pkg.isPinned) { // 非核心包才能删除
                await this.deletePackage(pkg.id);
                totalSize -= pkg.size;
            }
            index++;
        }
    }
    
    // 记录访问时间
    async markAsUsed(packageId) {
        await this.updateAccessTime(packageId, Date.now());
    }
}
```

**触发时机：**
- **App启动时**：检查并清理过期资源
- **定时任务**：每天凌晨执行清理
- **下载新包前**：检查存储空间是否充足
- **达到配额上限**：立即触发LRU清理

**清理优先级：**
```
1. 时间维度：
   - 超过7天未访问的离线包
   - 已过期的活动资源包
   - 旧版本的分包

2. 空间维度：
   - 总缓存超过配额（如500MB）
   - 按LRU排序删除最久未用的

3. 重要性维度：
   - 临时活动包（优先删除）
   - 普通分包（次要删除）
   - 核心主包（受保护，不删除）
```

#### 3.2.3 系统层面的清理

**iOS系统行为：**
- 存储空间严重不足时会清理`Library/Caches/`目录
- `Documents/`和`Library/Application Support/`不会被系统自动清理
- 开发者无法控制系统何时触发清理

**Android系统行为：**
- 存储不足时可能清理`cache/`目录
- 用户在系统设置中"清除缓存"会删除所有cache内容
- 外部存储的缓存更容易被清理

#### 3.2.4 用户主动清理

**App内清理入口：**
- 设置页面的"清理缓存"功能
- 存储空间管理界面
- 资源修复功能（删除并重新下载）

**系统设置清理：**
- iOS：设置 → 通用 → iPhone存储空间 → 清理缓存
- Android：设置 → 应用 → 存储 → 清除缓存

### 3.3 清理机制总结

| 清理类型 | 触发条件 | 影响范围 | 是否可恢复 |
|---------|---------|---------|-----------|
| 杀进程 | 用户或系统操作 | 仅内存 | ✅ 不影响离线包 |
| App LRU清理 | 过期/超配额 | 特定离线包 | ✅ 可重新下载 |
| 系统自动清理 | 存储空间不足 | cache目录 | ✅ 可重新下载 |
| 用户手动清理 | 主动操作 | 全部缓存 | ✅ 可重新下载 |
| 卸载App | 用户卸载 | 所有数据 | ❌ 无法恢复 |

## 四、离线包的更新机制

### 4.1 版本检查机制

**触发时机：**
- **App启动时**：检查是否有新版本
- **进入特定页面前**：按需检查分包版本
- **定时轮询**：后台定期检查更新
- **用户手动触发**：设置中的"检查更新"

**检查流程：**
```
1. 读取本地manifest文件
   ├─ 主包版本：v1.2.0
   ├─ 分包A版本：v1.1.0
   └─ 分包B版本：v1.0.5

2. 请求服务端获取最新manifest
   └─ CDN地址：https://cdn.game.com/manifest.json

3. 对比版本号
   ├─ 主包：v1.2.0 vs v1.3.0 → 需要更新
   ├─ 分包A：v1.1.0 vs v1.1.0 → 无需更新
   └─ 分包B：v1.0.5 vs v1.1.0 → 需要更新

4. 决定更新策略
   └─ 后台下载主包 + 分包B
```

### 4.2 主包与分包机制

#### 4.2.1 主包（首包）

**定义：**
安装或首次启动时下载的核心资源包。

**特点：**
- 内容与CDN版本号一一对应
- 每次Jenkins构建产生新的`cdnVersion`
- 包含游戏运行的必需资源
- 客户端根据`cdnVersion`判断是否需要重新下载

**版本管理：**
```json
// manifest.json示例
{
    "packageUrl": "https://cdn.game.com/main_v1.3.0.zip",
    "version": "1.3.0",
    "cdnVersion": "20241115_142530", // Jenkins构建时间戳
    "md5": "a1b2c3d4e5f6...",
    "size": 52428800,
    "assets": {
        "engine.js": { "md5": "...", "size": 1048576 },
        "main.js": { "md5": "...", "size": 2097152 }
    }
}
```

#### 4.2.2 分包（SubPackages）

**定义：**
按模块拆分的可选资源包，首包不包含这些资源。

**特点：**
- 客户端在使用到对应系统时才动态下载
- 下载完成后记录最后访问时间，用于LRU清理
- 可独立于主包进行更新
- 支持按需加载，减少首次下载时间

**manifest中的分包配置：**
```json
{
    "version": "1.3.0",
    "cdnVersion": "20241115_142530",
    "subPackages": [
        {
            "name": "battle_system",
            "version": "1.2.0",
            "url": "https://cdn.game.com/battle_v1.2.0.zip",
            "md5": "f1e2d3c4b5a6...",
            "size": 10485760,
            "priority": "high"
        },
        {
            "name": "social_system",
            "version": "1.0.5",
            "url": "https://cdn.game.com/social_v1.0.5.zip",
            "md5": "b2c3d4e5f6a7...",
            "size": 5242880,
            "priority": "low"
        },
        {
            "name": "activity_2024_11",
            "version": "1.0.0",
            "url": "https://cdn.game.com/activity_202411.zip",
            "md5": "c3d4e5f6a7b8...",
            "size": 8388608,
            "expiryDate": "2024-11-30",
            "priority": "medium"
        }
    ]
}
```

### 4.3 清理行为详解

#### 4.3.1 Cocos热更新框架的默认行为

**保留策略：**
```
1. 主包资源：
   - 始终保留当前版本的主包
   - 更新时替换为新版本
   - 不保留历史版本（除非配置保留）

2. 分包资源：
   - 只有超过磁盘配额时才清理
   - 长时间未访问的分包会被LRU淘汰
   - manifest中引用的分包不会自动删除
```

**清理触发条件：**
```javascript
// 清理逻辑伪代码
function shouldCleanSubPackage(subPackage) {
    // 条件1：manifest不再引用该分包
    if (!currentManifest.hasSubPackage(subPackage.name)) {
        return true;
    }
    
    // 条件2：超过7天未访问
    const daysSinceAccess = (Date.now() - subPackage.lastAccessTime) / (24 * 60 * 60 * 1000);
    if (daysSinceAccess > 7) {
        return true;
    }
    
    // 条件3：超过磁盘配额且该包优先级低
    if (isOverQuota() && subPackage.priority === 'low') {
        return true;
    }
    
    return false;
}
```

#### 4.3.2 版本更新时的清理行为

**场景1：Jenkins每次发版递增cdnVersion**
```
发版流程：
1. Jenkins构建新版本
   └─ 生成 cdnVersion: 20241115_142530

2. 客户端拉取新manifest
   └─ 检测到 cdnVersion 变化

3. 更新主包资源
   ├─ 下载新的主包
   ├─ 校验完整性
   └─ 替换旧主包

4. 处理分包
   ├─ 检查manifest中的subPackages列表
   ├─ 对比本地已下载的分包
   ├─ 仍在manifest中的分包：保留（除非hash变化）
   └─ 不在manifest中的分包：等待LRU清理
```

**场景2：分包资源未变化**
```
如果分包的实际内容没有变化：
- manifest会复用旧的md5/hash
- 客户端检测到hash相同，不重复下载
- 更新lastAccessTime，重置LRU计时

如果构建脚本强制重新打包：
- 即使内容相同，也会生成新的hash
- 客户端会重新下载（造成不必要的流量消耗）
```

### 4.4 版本号管理策略

#### 4.4.1 主包版本号

**基于构建策略：**
```bash
# Jenkins构建脚本示例
BUILD_TIME=$(date +%Y%m%d_%H%M%S)
CDN_VERSION="main_${BUILD_TIME}"

# 生成manifest
cat > manifest.json <<EOF
{
    "version": "1.3.0",
    "cdnVersion": "${CDN_VERSION}",
    "buildNumber": "${BUILD_NUMBER}"
}
EOF
```

**特点：**
- 每次构建都生成唯一的`cdnVersion`
- 客户端能准确感知每次发版
- 便于追踪和回滚

#### 4.4.2 分包版本号

**基于内容Hash（推荐）：**
```javascript
// 构建时计算资源hash
function generateSubPackageVersion(files) {
    const contentHash = calculateMD5(files);
    return {
        version: "1.2.0",
        hash: contentHash,
        url: `https://cdn.game.com/battle_${contentHash}.zip`
    };
}

// 优点：
// - 内容不变，hash不变，避免重复下载
// - 客户端精确知道资源是否需要更新
```

**基于时间戳（简单但低效）：**
```javascript
// 每次构建都生成新版本号
const subPackageVersion = {
    version: "1.2.0",
    buildTime: Date.now(),
    url: `https://cdn.game.com/battle_${Date.now()}.zip`
};

// 缺点：
// - 即使内容未变化也会生成新版本
// - 导致客户端不必要的重复下载
```

### 4.5 更新策略详解

#### 4.5.1 全量更新

**适用场景：**
- 包体积较小（<10MB）
- 资源变动较大
- 初次下载

**实现方式：**
```javascript
async function fullUpdate(packageInfo) {
    // 1. 下载完整包
    const zipFile = await downloadFile(packageInfo.url);
    
    // 2. 校验完整性
    const md5 = calculateMD5(zipFile);
    if (md5 !== packageInfo.md5) {
        throw new Error('Package corrupted');
    }
    
    // 3. 解压到临时目录
    await unzip(zipFile, '/temp/new_package/');
    
    // 4. 原子性替换
    await atomicReplace('/packages/current/', '/temp/new_package/');
    
    // 5. 更新版本记录
    await updateVersionInfo(packageInfo.version);
}
```

#### 4.5.2 增量更新（差分更新）

**适用场景：**
- 包体积较大（>50MB）
- 资源变动较小
- 节省流量

**实现方式：**
```javascript
async function incrementalUpdate(oldVersion, newVersion) {
    // 1. 请求差分包
    const diffPackage = await requestDiffPackage(oldVersion, newVersion);
    
    // 2. 下载差分包
    const diffFile = await downloadFile(diffPackage.url);
    
    // 3. 应用差分
    await applyPatch('/packages/current/', diffFile);
    
    // 4. 校验最终结果
    const finalMD5 = calculateDirectoryMD5('/packages/current/');
    if (finalMD5 !== newVersion.md5) {
        // 差分失败，回退到全量更新
        await fullUpdate(newVersion);
    }
}
```

#### 4.5.3 分片下载

**适用场景：**
- 网络不稳定
- 超大文件（>100MB）
- 需要断点续传

**实现方式：**
```javascript
async function chunkedDownload(packageInfo) {
    const chunkSize = 1024 * 1024; // 1MB per chunk
    const totalChunks = Math.ceil(packageInfo.size / chunkSize);
    
    for (let i = 0; i < totalChunks; i++) {
        const start = i * chunkSize;
        const end = Math.min(start + chunkSize, packageInfo.size);
        
        // 支持断点续传
        if (!await isChunkDownloaded(i)) {
            await downloadChunk(packageInfo.url, start, end, i);
        }
    }
    
    // 合并所有分片
    await mergeChunks(totalChunks);
}
```

### 4.6 更新时机策略

#### 4.6.1 静默更新（推荐）

```javascript
// 后台静默更新
async function silentUpdate() {
    // 1. 检查网络状态
    if (!isWiFiConnected()) {
        return; // 仅在WiFi下更新
    }
    
    // 2. 检查新版本
    const latestVersion = await checkUpdate();
    if (!latestVersion) return;
    
    // 3. 后台下载
    await downloadInBackground(latestVersion);
    
    // 4. 下次启动时激活
    markAsReadyToActivate(latestVersion);
}
```

**优点：**
- 不打扰用户体验
- 充分利用空闲时间
- 下次使用时直接加载新版本

#### 4.6.2 强制更新

```javascript
// 强制更新（阻塞式）
async function forceUpdate() {
    showUpdateDialog({
        title: "发现新版本",
        message: "需要更新资源才能继续游戏",
        cancelable: false
    });
    
    // 显示进度条
    const latestVersion = await checkUpdate();
    await downloadWithProgress(latestVersion, (progress) => {
        updateProgressBar(progress);
    });
    
    await activateNewVersion(latestVersion);
    restartGame();
}
```

**适用场景：**
- 重大bug修复
- 安全漏洞补丁
- 必须的兼容性更新

#### 4.6.3 预加载更新

```javascript
// 智能预加载
async function intelligentPreload() {
    // 预测用户可能访问的分包
    const predictedPackages = predictUserBehavior();
    
    for (const pkg of predictedPackages) {
        if (isWiFiConnected() && isIdle()) {
            await preloadPackage(pkg);
        }
    }
}
```

## 五、实战案例与最佳实践

### 5.1 典型的离线包架构

```
游戏资源架构：
├── 本地包（随安装，3-5MB）
│   ├── engine.js              # Cocos引擎核心（1.5MB）
│   ├── runtime.js             # 运行时库（500KB）
│   ├── loader.js              # 资源加载器（300KB）
│   ├── splash/                # 启动页资源（500KB）
│   └── basic-ui/              # 基础UI组件（1MB）
│
└── 离线包（动态下载）
    ├── main_package/          # 主包（15MB）
    │   ├── scenes/            # 核心场景
    │   ├── scripts/           # 游戏逻辑
    │   └── assets/            # 基础资源
    │
    ├── subpackages/           # 分包
    │   ├── battle_system/     # 战斗系统（8MB）
    │   ├── social_system/     # 社交系统（5MB）
    │   ├── shop_system/       # 商城系统（3MB）
    │   └── activity_202411/   # 当前活动（4MB）
    │
    └── assets/                # 媒体资源
        ├── audio/             # 音频包（10MB）
        ├── video/             # 视频包（20MB）
        └── textures/          # 高清贴图（30MB）
```

### 5.2 版本管理最佳实践

#### 5.2.1 主包版本策略

```json
// manifest.json 完整示例
{
    "gameVersion": "1.3.0",
    "cdnVersion": "20241115_142530",
    "buildNumber": 1523,
    
    "mainPackage": {
        "version": "1.3.0",
        "url": "https://cdn.game.com/main/main_20241115_142530.zip",
        "md5": "a1b2c3d4e5f67890",
        "size": 15728640,
        "mandatory": true,
        "assets": {
            "scenes/login.scene": {
                "md5": "f1e2d3c4b5a6",
                "size": 524288
            },
            "scripts/game.js": {
                "md5": "b2c3d4e5f6a7",
                "size": 1048576
            }
        }
    },
    
    "subPackages": [
        {
            "id": "battle",
            "name": "战斗系统",
            "version": "1.2.0",
            "url": "https://cdn.game.com/sub/battle_v1.2.0.zip",
            "md5": "c3d4e5f6a7b8",
            "size": 8388608,
            "priority": "high",
            "lazyLoad": false,
            "dependencies": ["main"]
        },
        {
            "id": "activity_202411",
            "name": "感恩节活动",
            "version": "1.0.0",
            "url": "https://cdn.game.com/sub/activity_202411.zip",
            "md5": "d4e5f6a7b8c9",
            "size": 4194304,
            "priority": "medium",
            "lazyLoad": true,
            "expiryDate": "2024-11-30T23:59:59Z"
        }
    ],
    
    "assetBundles": [
        {
            "id": "audio",
            "url": "https://cdn.game.com/assets/audio.zip",
            "md5": "e5f6a7b8c9d0",
            "size": 10485760,
            "priority": "low",
            "preload": false
        }
    ]
}
```

#### 5.2.2 智能更新策略

```javascript
class SmartUpdateManager {
    constructor() {
        this.updateQueue = [];
        this.downloadingPackages = new Set();
    }
    
    // 检查并规划更新
    async planUpdate() {
        const manifest = await this.fetchLatestManifest();
        const localManifest = await this.getLocalManifest();
        
        // 1. 检查主包
        if (manifest.mainPackage.version !== localManifest.mainPackage.version) {
            this.updateQueue.push({
                type: 'main',
                package: manifest.mainPackage,
                priority: 10 // 最高优先级
            });
        }
        
        // 2. 检查分包
        for (const subPkg of manifest.subPackages) {
            const localPkg = this.findLocalSubPackage(subPkg.id);
            
            if (!localPkg || localPkg.md5 !== subPkg.md5) {
                this.updateQueue.push({
                    type: 'sub',
                    package: subPkg,
                    priority: this.calculatePriority(subPkg)
                });
            }
        }
        
        // 3. 按优先级排序
        this.updateQueue.sort((a, b) => b.priority - a.priority);
    }
    
    // 计算分包优先级
    calculatePriority(subPackage) {
        let priority = 0;
        
        // 基础优先级
        if (subPackage.priority === 'high') priority += 8;
        else if (subPackage.priority === 'medium') priority += 5;
        else priority += 2;
        
        // 非懒加载的包优先级更高
        if (!subPackage.lazyLoad) priority += 3;
        
        // 用户可能很快用到的包
        if (this.isPredictedToUse(subPackage)) priority += 2;
        
        return priority;
    }
    
    // 执行更新
    async executeUpdate() {
        // 检查网络状态
        const networkType = await this.getNetworkType();
        
        for (const item of this.updateQueue) {
            // WiFi环境：下载所有
            // 4G环境：只下载高优先级
            if (networkType === '4G' && item.priority < 7) {
                console.log(`跳过低优先级包: ${item.package.name}`);
                continue;
            }
            
            await this.downloadPackage(item.package);
        }
    }
    
    // 下载包
    async downloadPackage(packageInfo) {
        if (this.downloadingPackages.has(packageInfo.id)) {
            return; // 避免重复下载
        }
        
        this.downloadingPackages.add(packageInfo.id);
        
        try {
            // 1. 下载到临时目录
            const tempPath = `/temp/${packageInfo.id}_${Date.now()}.zip`;
            await this.download(packageInfo.url, tempPath, (progress) => {
                this.onDownloadProgress(packageInfo.id, progress);
            });
            
            // 2. 校验完整性
            const md5 = await this.calculateMD5(tempPath);
            if (md5 !== packageInfo.md5) {
                throw new Error('MD5校验失败');
            }
            
            // 3. 解压
            const extractPath = `/packages/${packageInfo.id}/`;
            await this.unzip(tempPath, extractPath);
            
            // 4. 更新记录
            await this.updatePackageInfo(packageInfo);
            
            // 5. 清理临时文件
            await this.deleteFile(tempPath);
            
            console.log(`包更新成功: ${packageInfo.name}`);
        } catch (error) {
            console.error(`包更新失败: ${packageInfo.name}`, error);
            // 重试逻辑
            await this.retryDownload(packageInfo);
        } finally {
            this.downloadingPackages.delete(packageInfo.id);
        }
    }
}
```

### 5.3 存储治理策略

```javascript
class StorageGovernance {
    constructor() {
        this.maxCacheSize = 500 * 1024 * 1024; // 500MB
        this.maxAge = 7 * 24 * 60 * 60 * 1000; // 7天
        this.protectedPackages = ['main', 'battle']; // 受保护的包
    }
    
    // 清理策略
    async cleanup() {
        const packages = await this.getAllPackages();
        const now = Date.now();
        
        // 1. 删除过期包
        for (const pkg of packages) {
            // 跳过受保护的包
            if (this.protectedPackages.includes(pkg.id)) {
                continue;
            }
            
            // 检查是否过期
            if (pkg.expiryDate && now > new Date(pkg.expiryDate).getTime()) {
                await this.deletePackage(pkg.id);
                console.log(`删除过期包: ${pkg.name}`);
            }
        }
        
        // 2. LRU清理
        await this.lruCleanup(packages);
    }
    
    async lruCleanup(packages) {
        // 计算当前总大小
        let totalSize = packages.reduce((sum, pkg) => sum + pkg.size, 0);
        
        if (totalSize <= this.maxCacheSize) {
            return; // 未超配额
        }
        
        // 按最后访问时间排序
        const sortedPackages = packages
            .filter(pkg => !this.protectedPackages.includes(pkg.id))
            .sort((a, b) => a.lastAccessTime - b.lastAccessTime);
        
        // 删除最久未使用的包，直到低于配额
        for (const pkg of sortedPackages) {
            if (totalSize <= this.maxCacheSize * 0.8) {
                break; // 保留20%缓冲空间
            }
            
            await this.deletePackage(pkg.id);
            totalSize -= pkg.size;
            console.log(`LRU删除: ${pkg.name}, 释放${pkg.size}字节`);
        }
    }
    
    // 更新访问时间
    async markAsAccessed(packageId) {
        await this.updateDB({
            id: packageId,
            lastAccessTime: Date.now()
        });
    }
}
```

### 5.4 容错与降级

```javascript
class FallbackManager {
    // 检查资源完整性
    async verifyIntegrity() {
        const packages = await this.getAllPackages();
        
        for (const pkg of packages) {
            if (!await this.isPackageValid(pkg)) {
                console.warn(`检测到损坏的包: ${pkg.name}`);
                await this.handleCorruptedPackage(pkg);
            }
        }
    }
    
    // 处理损坏的包
    async handleCorruptedPackage(pkg) {
        // 1. 删除损坏的包
        await this.deletePackage(pkg.id);
        
        // 2. 重新下载
        try {
            await this.downloadPackage(pkg);
        } catch (error) {
            console.error(`重新下载失败: ${pkg.name}`);
            
            // 3. 降级处理
            if (pkg.type === 'main') {
                // 主包损坏，使用本地包
                await this.useLocalPackage();
            } else {
                // 分包损坏，禁用对应功能
                await this.disableFeature(pkg.id);
            }
        }
    }
    
    // 网络异常降级
    async handleNetworkError() {
        // 使用已缓存的资源
        const cachedPackages = await this.getCachedPackages();
        
        if (cachedPackages.length > 0) {
            console.log('网络异常，使用缓存资源');
            return cachedPackages;
        }
        
        // 回退到本地包
        console.log('无可用缓存，使用本地基础资源');
        return await this.getLocalPackages();
    }
}
```

## 六、常见问题与排查

### 6.1 为什么离线包会被清理？

**可能原因：**
1. 超过7天未访问（LRU策略）
2. 超过磁盘配额限制
3. 系统存储空间不足
4. 用户手动清理缓存
5. manifest不再引用该包

**排查方法：**
```javascript
// 记录清理日志
function logCleanup(packageId, reason) {
    const log = {
        timestamp: Date.now(),
        packageId: packageId,
        reason: reason,
        freeSpace: getAvailableSpace()
    };
    
    reportToServer(log); // 上报到监控系统
}
```

### 6.2 每次发版是否会清理所有旧包？

**答案：不会**

**原因：**
- Cocos热更新框架默认保留当前版本主包
- 分包只在以下情况被清理：
  - manifest不再引用
  - 超过LRU配额
  - 长时间未访问
  
**验证方法：**
```javascript
// 发版前后对比
async function comparePackages() {
    const before = await this.getPackageList();
    
    // 执行更新
    await this.updateToNewVersion();
    
    const after = await this.getPackageList();
    
    // 对比差异
    const deleted = before.filter(p => !after.includes(p));
    const added = after.filter(p => !before.includes(p));
    
    console.log('删除的包:', deleted);
    console.log('新增的包:', added);
}
```

### 6.3 如何避免不必要的重复下载？

**最佳实践：**

1. **使用内容Hash而非时间戳**
```javascript
// ❌ 错误做法：每次都生成新版本号
const version = Date.now();

// ✅ 正确做法：基于内容hash
const version = calculateMD5(packageContent);
```

2. **在manifest中复用未变化资源的hash**
```json
{
    "subPackages": [
        {
            "id": "battle",
            "version": "1.2.0",
            "md5": "a1b2c3d4" // 内容未变，hash不变
        }
    ]
}
```

3. **客户端对比hash决定是否下载**
```javascript
async function needDownload(remotePackage) {
    const localPackage = await this.getLocalPackage(remotePackage.id);
    
    // 对比hash而非版本号
    return !localPackage || localPackage.md5 !== remotePackage.md5;
}
```

## 七、总结与建议

### 7.1 核心要点

1. **离线包存储在App的缓存目录**，不会因杀进程而清理，但会受LRU等存储策略影响

2. **主包与分包采用不同的管理策略**：
   - 主包：随版本更新替换，受保护不被LRU清理
   - 分包：按需下载，受LRU管理，可被清理

3. **版本更新不会清空所有旧包**，只清理不再被manifest引用或长期未使用的包

4. **版本号管理应基于内容Hash**，避免不必要的重复下载

### 7.2 实施建议

**对于游戏开发者：**
1. 合理拆分主包与分包，控制首包体积
2. 实施基于hash的版本管理
3. 配置合理的LRU清理策略
4. 实现完善的容错和降级机制
5. 监控离线包的下载成功率和清理情况

**对于构建系统：**
1. 只在资源实际变化时更新hash
2. 提供灰度发布能力
3. 支持快速回滚
4. 记录详细的构建日志

**对于客户端：**
1. 实现智能的下载调度
2. 提供清晰的存储管理界面
3. 记录并上报清理事件
4. 优化用户提示和进度展示

通过以上机制和策略，可以在保证游戏体验的同时，有效管理存储空间，实现资源的灵活更新和高效利用。
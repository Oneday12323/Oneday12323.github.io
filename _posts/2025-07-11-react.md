---
title: React- 点击按钮执行耗时函数与setState工作原理详解
tags: React setState loading 状态
article_header:
  type: cover
---

## 在React组件中，点击按钮执行耗时10秒函数并设置loading状态为true，loading效果是否立刻显示?
在 React 18 中，loading 效果**不会立刻显示**。

### 原因分析

当点击按钮时发生的事情：

1. **事件处理函数开始执行**
2. `setLoading(true)` 被调用
3. **耗时 10 秒的同步函数立即执行**（阻塞主线程）
4. 在这 10 秒期间，JavaScript 主线程被完全占用
5. React 无法进行重新渲染
6. 10 秒后函数执行完毕
7. `setLoading(false)` 被调用
8. 此时 React 才开始处理状态更新和重新渲染

### 问题代码示例

```jsx
function App() {
  const [loading, setLoading] = useState(false);

  const heavyTask = () => {
    const start = Date.now();
    while (Date.now() - start < 10000) {
      // 同步阻塞 10 秒
    }
  };

  const handleClick = () => {
    setLoading(true);  // 状态更新排队
    heavyTask();       // 阻塞主线程 10 秒
    setLoading(false); // 状态更新排队
    // React 在这里才能处理状态更新，但 loading 已经是 false 了
  };

  return (
    <div>
      {loading && <p>加载中...</p>}
      <button onClick={handleClick}>执行任务</button>
    </div>
  );
}
```

### 解决方案

#### 方案 1：使用 `setTimeout` 让渲染先发生

```jsx
const handleClick = () => {
  setLoading(true);
  setTimeout(() => {
    heavyTask();
    setLoading(false);
  }, 0);
};
```

#### 方案 2：使用 Web Worker（推荐用于真正的耗时计算）

```jsx
const handleClick = () => {
  setLoading(true);
  const worker = new Worker('worker.js');
  worker.onmessage = () => {
    setLoading(false);
  };
  worker.postMessage('start');
};
```

#### 方案 3：将任务拆分成异步块

```jsx
const handleClick = async () => {
  setLoading(true);
  await new Promise(resolve => setTimeout(resolve, 0));
  heavyTask();
  setLoading(false);
};
```

关键点是：**必须让事件处理函数先返回，给浏览器机会进行重新渲染**，否则同步的长时间计算会完全阻塞 UI 更新。

### 方案 4：使用 React 18 的 `startTransition`

```jsx
import { startTransition } from 'react';

const handleClick = () => {
  setLoading(true);
  startTransition(() => {
    heavyTask();
    setLoading(false);
  });
};
```

不过需要注意，`startTransition` 主要用于标记非紧急更新，**并不能解决同步阻塞问题**。它更适合处理大量 DOM 更新，而非长时间的同步计算。

### 方案 5：使用 `requestIdleCallback`

在浏览器空闲时执行任务：

```jsx
const handleClick = () => {
  setLoading(true);
  requestIdleCallback(() => {
    heavyTask();
    setLoading(false);
  });
};
```

### 方案 6：将任务分片执行（Time Slicing）

将长任务拆分成多个小任务，每个小任务之间让出控制权：

```jsx
const handleClick = async () => {
  setLoading(true);
  
  await heavyTaskInChunks();
  
  setLoading(false);
};

const heavyTaskInChunks = () => {
  return new Promise(resolve => {
    let i = 0;
    const total = 10000000;
    const chunkSize = 100000;
    
    function processChunk() {
      const end = Math.min(i + chunkSize, total);
      
      // 处理当前块
      for (; i < end; i++) {
        // 执行计算
      }
      
      if (i < total) {
        // 让出控制权，允许浏览器渲染
        setTimeout(processChunk, 0);
      } else {
        resolve();
      }
    }
    
    processChunk();
  });
};
```

### 方案 7：使用 `scheduler` 包（实验性）

React 团队提供的调度器：

```jsx
import { unstable_scheduleCallback, unstable_NormalPriority } from 'scheduler';

const handleClick = () => {
  setLoading(true);
  unstable_scheduleCallback(unstable_NormalPriority, () => {
    heavyTask();
    setLoading(false);
  });
};
```

### 方案 8：使用 `queueMicrotask`

```jsx
const handleClick = () => {
  setLoading(true);
  queueMicrotask(() => {
    setTimeout(() => {
      heavyTask();
      setLoading(false);
    }, 0);
  });
};
```

### 方案 9：使用 `flushSync` 强制同步渲染（谨慎使用）

```jsx
import { flushSync } from 'react-dom';

const handleClick = () => {
  flushSync(() => {
    setLoading(true);
  });
  // 此时 loading 已经渲染到 DOM
  setTimeout(() => {
    heavyTask();
    setLoading(false);
  }, 0);
};
```

### 总结

对于真正的耗时操作，推荐优先级：

1. **Web Worker** - 适合 CPU 密集型计算，不阻塞主线程
2. **任务分片** - 适合可拆分的大任务
3. **setTimeout(fn, 0)** - 简单有效的通用方案
4. **服务端处理** - 如果可能，将耗时操作放到后端

## setState改变状态时React背后工作原理及状态变更和页面渲染时机

### 一、setState 的工作流程

#### 1. 状态更新的完整过程

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    console.log('1. 调用 setCount');
    setCount(count + 1);
    console.log('2. setCount 调用完成，但 count 还是:', count);
    // count 仍然是 0，因为状态更新是异步的
  };
  
  console.log('3. 组件渲染，count:', count);
  
  return <button onClick={handleClick}>{count}</button>;
}
```

**背后发生的事情：**

1. **调用 setState** → 创建一个更新对象
2. **更新入队** → 将更新放入 fiber 节点的更新队列
3. **调度更新** → 通知 React 调度器有更新需要处理
4. **开始协调** → React 开始 reconciliation（协调）过程
5. **计算新状态** → 处理队列中的所有更新，计算最终状态
6. **生成新 fiber 树** → 创建新的 fiber 节点树
7. **Diff 算法** → 对比新旧 fiber 树，找出变化
8. **提交阶段** → 将变化应用到真实 DOM
9. **浏览器渲染** → 浏览器重绘页面

### 二、React 18 的并发特性

### 批量更新（Automatic Batching）

**React 18 之前：**

```jsx
// React 17 及以前
function handleClick() {
  setCount(c => c + 1);     // 触发重新渲染
  setFlag(f => !f);         // 触发重新渲染
  // 在事件处理器中会自动批处理 → 只渲染 1 次
}

setTimeout(() => {
  setCount(c => c + 1);     // 触发重新渲染
  setFlag(f => !f);         // 触发重新渲染
  // 在 setTimeout 中不会批处理 → 渲染 2 次
}, 1000);

fetch('/api').then(() => {
  setCount(c => c + 1);     // 触发重新渲染
  setFlag(f => !f);         // 触发重新渲染
  // 在 Promise 中不会批处理 → 渲染 2 次
});
```

**React 18：**

```jsx
// React 18 自动批处理所有更新
function handleClick() {
  setCount(c => c + 1);
  setFlag(f => !f);
  // 只渲染 1 次
}

setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // 只渲染 1 次（自动批处理）
}, 1000);

fetch('/api').then(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // 只渲染 1 次（自动批处理）
});
```

#### 如何退出自动批处理

```jsx
import { flushSync } from 'react-dom';

function handleClick() {
  flushSync(() => {
    setCount(c => c + 1);
  }); // 第 1 次渲染
  
  flushSync(() => {
    setFlag(f => !f);
  }); // 第 2 次渲染
}
```

### 三、状态更新的时机

#### 同步 vs 异步模式

```jsx
function App() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    console.log('Before:', count); // 0
    
    setCount(1);
    console.log('After:', count);  // 仍然是 0
    
    setCount(2);
    console.log('After:', count);  // 仍然是 0
    
    // 最终只会渲染一次，count 变为 2
  };

  return <button onClick={handleClick}>{count}</button>;
}
```

**为什么 count 不立即更新？**

1. **闭包特性**：`count` 是当前渲染时的快照值
2. **批量处理**：多个 setState 会被合并
3. **异步调度**：更新不会立即执行，而是被调度

#### 获取最新状态的方法

**方法 1：使用函数式更新**

```jsx
const handleClick = () => {
  setCount(prevCount => {
    console.log('当前状态:', prevCount);
    return prevCount + 1;
  });
};
```

**方法 2：使用 useEffect**

```jsx
useEffect(() => {
  console.log('count 已更新:', count);
}, [count]);
```

**方法 3：使用 flushSync（不推荐）**

```jsx
import { flushSync } from 'react-dom';

const handleClick = () => {
  flushSync(() => {
    setCount(1);
  });
  console.log('count 已同步更新');
  // 此时可以访问更新后的 DOM
};
```

### 四、渲染时机详解

#### Render 阶段（可中断）

这个阶段 React 会：

1. 调用函数组件或类组件的 render 方法
2. 执行 Hooks（useState, useEffect 等）
3. 进行 Diff 算法比较
4. 标记需要更新的节点

**特点：** 纯计算，可以被中断、暂停、重启

#### Commit 阶段（不可中断）

这个阶段 React 会：

1. **Before Mutation**：读取 DOM 状态
2. **Mutation**：更新真实 DOM
3. **Layout**：执行 useLayoutEffect，可以同步读取 DOM

**特点：** 同步执行，不可中断

```jsx
function Example() {
  const [count, setCount] = useState(0);
  
  // Render 阶段
  console.log('1. Render 阶段，count:', count);
  
  // Commit 阶段 - Before Mutation
  useEffect(() => {
    console.log('2. useEffect 执行（异步）');
  });
  
  // Commit 阶段 - Layout
  useLayoutEffect(() => {
    console.log('3. useLayoutEffect 执行（同步）');
  });
  
  return <div>{count}</div>;
}

// 执行顺序：
// 1. Render 阶段，count: 0
// 3. useLayoutEffect 执行（同步）
// [浏览器绘制]
// 2. useEffect 执行（异步）
```

### 五、优先级调度

React 18 引入了优先级概念：

```jsx
import { startTransition } from 'react';

function SearchBox() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);
  
  const handleChange = (e) => {
    // 高优先级：立即更新输入框
    setInput(e.target.value);
    
    // 低优先级：延迟更新列表
    startTransition(() => {
      setList(filterList(e.target.value));
    });
  };
  
  return (
    <>
      <input value={input} onChange={handleChange} />
      <List items={list} />
    </>
  );
}
```

**优先级分类：**

- **同步优先级**：flushSync，立即执行
- **用户交互优先级**：点击、输入等
- **过渡优先级**：startTransition
- **空闲优先级**：数据预加载等

### 六、实际应用示例

```jsx
function ComplexComponent() {
  const [count, setCount] = useState(0);
  const [loading, setLoading] = useState(false);
  
  const handleComplexUpdate = async () => {
    // 1. 立即显示 loading
    flushSync(() => {
      setLoading(true);
    });
    
    // 2. 执行异步操作
    await someAsyncTask();
    
    // 3. 批量更新状态
    setCount(10);
    setLoading(false);
    // 这两个更新会被自动批处理，只渲染一次
  };
  
  return (
    <div>
      {loading ? <Spinner /> : <Content count={count} />}
      <button onClick={handleComplexUpdate}>更新</button>
    </div>
  );
}
```

### 总结

**关键点：**

1. setState 是**异步的**，不会立即更新状态
2. React 18 对**所有更新**都自动批处理
3. 渲染分为 **Render 和 Commit** 两个阶段
4. 使用 **函数式更新** 获取最新状态
5. 使用 **startTransition** 标记低优先级更新
6. 使用 **flushSync** 强制同步更新（谨慎使用）
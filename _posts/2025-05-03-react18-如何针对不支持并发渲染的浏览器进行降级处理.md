> 并发渲染的浏览器降级处理策略

## 1. 浏览器能力检测

### 基础能力检测
```javascript
// 检测并发渲染相关的浏览器特性
function detectConcurrentSupport() {
  const checks = {
    // React 18 createRoot API
    createRoot: typeof window !== 'undefined' && 
                typeof document?.createElement === 'function',
    
    // MessageChannel (时间切片基础)
    messageChannel: typeof MessageChannel !== 'undefined',
    
    // requestIdleCallback (性能优化)
    requestIdleCallback: typeof requestIdleCallback !== 'undefined',
    
    // Performance API
    performanceNow: typeof performance?.now === 'function',
    
    // WeakMap/WeakSet (内存管理)
    weakCollections: typeof WeakMap !== 'undefined' && 
                    typeof WeakSet !== 'undefined',
    
    // Promise (异步处理)
    promise: typeof Promise !== 'undefined',
    
    // ES6+ 特性
    es6Support: typeof Symbol !== 'undefined' && 
                typeof Map !== 'undefined'
  };

  const supportLevel = Object.values(checks).filter(Boolean).length;
  const totalChecks = Object.keys(checks).length;
  
  return {
    ...checks,
    supportLevel,
    isFullySupported: supportLevel === totalChecks,
    isPartiallySupported: supportLevel >= totalChecks * 0.7
  };
}
```

### React版本检测
```javascript
// 检测当前React版本和功能可用性
function detectReactCapabilities() {
  try {
    // 检测React 18特性
    const hasCreateRoot = typeof require('react-dom/client')?.createRoot === 'function';
    const hasTransition = typeof require('react')?.useTransition === 'function';
    const hasSuspense = typeof require('react')?.Suspense !== 'undefined';
    
    return {
      version: require('react').version,
      hasCreateRoot,
      hasTransition,
      hasSuspense,
      isConcurrentCapable: hasCreateRoot && hasTransition
    };
  } catch (error) {
    return {
      version: 'unknown',
      hasCreateRoot: false,
      hasTransition: false,
      hasSuspense: false,
      isConcurrentCapable: false
    };
  }
}
```

## 2. 渐进式降级架构

### 应用初始化层
```javascript
// AppInitializer.js - 统一的应用初始化器
import React from 'react';

class AppInitializer {
  constructor() {
    this.capabilities = this.detectCapabilities();
    this.renderMode = this.determineRenderMode();
  }

  detectCapabilities() {
    const browser = detectConcurrentSupport();
    const react = detectReactCapabilities();
    
    return { browser, react };
  }

  determineRenderMode() {
    const { browser, react } = this.capabilities;
    
    if (react.isConcurrentCapable && browser.isFullySupported) {
      return 'concurrent';
    } else if (react.hasSuspense && browser.isPartiallySupported) {
      return 'legacy-with-suspense';
    } else {
      return 'legacy';
    }
  }

  createRenderer(container) {
    switch (this.renderMode) {
      case 'concurrent':
        return this.createConcurrentRenderer(container);
      case 'legacy-with-suspense':
        return this.createLegacyWithSuspenseRenderer(container);
      default:
        return this.createLegacyRenderer(container);
    }
  }

  createConcurrentRenderer(container) {
    const { createRoot } = require('react-dom/client');
    const root = createRoot(container);
    
    return {
      render: (element) => root.render(element),
      unmount: () => root.unmount(),
      mode: 'concurrent'
    };
  }

  createLegacyWithSuspenseRenderer(container) {
    const ReactDOM = require('react-dom');
    
    return {
      render: (element) => ReactDOM.render(element, container),
      unmount: () => ReactDOM.unmountComponentAtNode(container),
      mode: 'legacy-with-suspense'
    };
  }

  createLegacyRenderer(container) {
    const ReactDOM = require('react-dom');
    
    return {
      render: (element) => ReactDOM.render(element, container),
      unmount: () => ReactDOM.unmountComponentAtNode(container),
      mode: 'legacy'
    };
  }
}

// 导出单例
export default new AppInitializer();
```

### 应用入口适配
```javascript
// index.js - 应用入口
import React from 'react';
import App from './App';
import appInitializer from './AppInitializer';

async function startApp() {
  const container = document.getElementById('root');
  const renderer = appInitializer.createRenderer(container);
  
  // 根据渲染模式包装App组件
  const WrappedApp = wrapAppForMode(App, renderer.mode);
  
  renderer.render(<WrappedApp />);
  
  // 性能监控
  reportRenderMode(renderer.mode);
}

function wrapAppForMode(AppComponent, mode) {
  switch (mode) {
    case 'concurrent':
      return () => (
        <React.StrictMode>
          <ConcurrentWrapper>
            <AppComponent />
          </ConcurrentWrapper>
        </React.StrictMode>
      );
      
    case 'legacy-with-suspense':
      return () => (
        <SuspenseWrapper>
          <AppComponent />
        </SuspenseWrapper>
      );
      
    default:
      return () => (
        <LegacyWrapper>
          <AppComponent />
        </LegacyWrapper>
      );
  }
}

startApp();
```

## 3. Hook适配层

### 并发Hook的降级实现
```javascript
// hooks/adaptive.js - 自适应Hook实现
import React, { useState, useCallback, useMemo } from 'react';
import appInitializer from '../AppInitializer';

// useTransition的降级实现
export function useAdaptiveTransition() {
  const mode = appInitializer.renderMode;
  
  if (mode === 'concurrent') {
    // React 18并发模式
    const { useTransition } = require('react');
    return useTransition();
  } else {
    // 降级实现
    const [isPending, setIsPending] = useState(false);
    
    const startTransition = useCallback((callback) => {
      if (mode === 'legacy-with-suspense') {
        // 使用setTimeout模拟异步
        setIsPending(true);
        setTimeout(() => {
          try {
            callback();
          } finally {
            setIsPending(false);
          }
        }, 0);
      } else {
        // 同步执行
        callback();
      }
    }, [mode]);
    
    return [isPending, startTransition];
  }
}

// useDeferredValue的降级实现
export function useAdaptiveDeferredValue(value, timeoutMs = 200) {
  const mode = appInitializer.renderMode;
  
  if (mode === 'concurrent') {
    const { useDeferredValue } = require('react');
    return useDeferredValue(value);
  } else {
    // 使用防抖实现降级
    const [deferredValue, setDeferredValue] = useState(value);
    
    useMemo(() => {
      if (mode === 'legacy-with-suspense') {
        const timer = setTimeout(() => {
          setDeferredValue(value);
        }, timeoutMs);
        
        return () => clearTimeout(timer);
      } else {
        // 同步更新
        setDeferredValue(value);
      }
    }, [value, timeoutMs, mode]);
    
    return deferredValue;
  }
}

// Suspense的降级实现
export function AdaptiveSuspense({ children, fallback }) {
  const mode = appInitializer.renderMode;
  
  if (mode === 'concurrent' || mode === 'legacy-with-suspense') {
    return (
      <React.Suspense fallback={fallback}>
        {children}
      </React.Suspense>
    );
  } else {
    // 降级为错误边界 + 加载状态
    return (
      <LegacySuspenseWrapper fallback={fallback}>
        {children}
      </LegacySuspenseWrapper>
    );
  }
}
```

### 组件适配示例
```javascript
// components/SearchBox.js - 搜索组件的适配实现
import React, { useState, useMemo } from 'react';
import { useAdaptiveTransition, useAdaptiveDeferredValue } from '../hooks/adaptive';

function SearchBox({ onSearch, data }) {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useAdaptiveTransition();
  const deferredQuery = useAdaptiveDeferredValue(query);

  // 根据查询条件过滤数据
  const filteredData = useMemo(() => {
    if (!deferredQuery) return data;
    return data.filter(item => 
      item.name.toLowerCase().includes(deferredQuery.toLowerCase())
    );
  }, [data, deferredQuery]);

  const handleInputChange = (e) => {
    const value = e.target.value;
    setQuery(value); // 立即更新输入框
    
    // 使用适配的transition
    startTransition(() => {
      onSearch(value);
    });
  };

  return (
    <div className="search-box">
      <input
        type="text"
        value={query}
        onChange={handleInputChange}
        placeholder="搜索..."
        className={isPending ? 'searching' : ''}
      />
      
      <div className={`results ${isPending ? 'loading' : ''}`}>
        {filteredData.map(item => (
          <div key={item.id} className="search-result">
            {item.name}
          </div>
        ))}
      </div>
      
      {isPending && (
        <div className="search-indicator">
          搜索中...
        </div>
      )}
    </div>
  );
}

export default SearchBox;
```

## 4. 性能优化的降级策略

### 虚拟滚动的适配
```javascript
// components/AdaptiveVirtualList.js
import React, { useState, useEffect, useMemo } from 'react';
import { useAdaptiveTransition } from '../hooks/adaptive';
import appInitializer from '../AppInitializer';

function AdaptiveVirtualList({ items, itemHeight = 50, containerHeight = 400 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const [isPending, startTransition] = useAdaptiveTransition();
  const mode = appInitializer.renderMode;

  // 根据模式调整渲染策略
  const renderStrategy = useMemo(() => {
    if (mode === 'concurrent') {
      return {
        bufferSize: 10, // 并发模式可以处理更多缓冲
        updateDelay: 0,
        useVirtualization: true
      };
    } else if (mode === 'legacy-with-suspense') {
      return {
        bufferSize: 5,
        updateDelay: 16, // 一帧的时间
        useVirtualization: true
      };
    } else {
      return {
        bufferSize: 3,
        updateDelay: 100,
        useVirtualization: items.length > 100 // 只在大数据时启用
      };
    }
  }, [mode, items.length]);

  // 计算可见项目
  const visibleItems = useMemo(() => {
    if (!renderStrategy.useVirtualization) {
      return items; // 小数据集直接渲染所有项目
    }

    const { bufferSize } = renderStrategy;
    const visibleCount = Math.ceil(containerHeight / itemHeight);
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + visibleCount + bufferSize,
      items.length
    );
    const actualStartIndex = Math.max(0, startIndex - bufferSize);

    return items.slice(actualStartIndex, endIndex).map((item, index) => ({
      ...item,
      index: actualStartIndex + index,
      top: (actualStartIndex + index) * itemHeight
    }));
  }, [items, scrollTop, itemHeight, containerHeight, renderStrategy]);

  const handleScroll = (e) => {
    const newScrollTop = e.target.scrollTop;
    
    if (mode === 'concurrent') {
      // 并发模式：使用transition
      startTransition(() => {
        setScrollTop(newScrollTop);
      });
    } else {
      // 降级模式：防抖处理
      clearTimeout(handleScroll.timeoutId);
      handleScroll.timeoutId = setTimeout(() => {
        setScrollTop(newScrollTop);
      }, renderStrategy.updateDelay);
    }
  };

  return (
    <div 
      className="virtual-list-container"
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div 
        className="virtual-list-content"
        style={{ 
          height: renderStrategy.useVirtualization 
            ? items.length * itemHeight 
            : 'auto',
          position: 'relative'
        }}
      >
        {visibleItems.map(item => (
          <div
            key={item.id || item.index}
            className="virtual-list-item"
            style={renderStrategy.useVirtualization ? {
              position: 'absolute',
              top: item.top,
              height: itemHeight,
              width: '100%'
            } : {
              height: itemHeight
            }}
          >
            {item.content || item.name}
          </div>
        ))}
      </div>
      
      {isPending && mode === 'concurrent' && (
        <div className="loading-indicator">更新中...</div>
      )}
    </div>
  );
}

export default AdaptiveVirtualList;
```

## 5. Polyfill和兼容性处理

### 核心API的Polyfill
```javascript
// polyfills/concurrent.js
class ConcurrentPolyfills {
  static install() {
    // MessageChannel polyfill
    if (!window.MessageChannel) {
      window.MessageChannel = class {
        constructor() {
          this.port1 = {
            postMessage: (data) => {
              setTimeout(() => {
                if (this.port2.onmessage) {
                  this.port2.onmessage({ data });
                }
              }, 0);
            }
          };
          this.port2 = { onmessage: null };
        }
      };
    }

    // requestIdleCallback polyfill
    if (!window.requestIdleCallback) {
      window.requestIdleCallback = (callback, options = {}) => {
        const timeout = options.timeout || 0;
        const start = performance.now();
        
        return setTimeout(() => {
          callback({
            didTimeout: timeout > 0 && (performance.now() - start) >= timeout,
            timeRemaining: () => Math.max(0, 50 - (performance.now() - start))
          });
        }, 1);
      };
      
      window.cancelIdleCallback = (id) => {
        clearTimeout(id);
      };
    }

    // Performance.now polyfill
    if (!window.performance || !window.performance.now) {
      window.performance = window.performance || {};
      window.performance.now = () => Date.now();
    }
  }
}

// 在应用启动前安装polyfills
ConcurrentPolyfills.install();
```

### 错误边界和降级组件
```javascript
// components/ConcurrentErrorBoundary.js
import React from 'react';

class ConcurrentErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // 记录并发渲染相关错误
    console.warn('Concurrent rendering error:', error, errorInfo);
    
    // 报告错误（可选）
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="concurrent-error-fallback">
          <h3>渲染遇到问题</h3>
          <p>正在使用兼容模式重新加载...</p>
          <button onClick={() => window.location.reload()}>
            刷新页面
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 用于包装应用的高阶组件
export function withConcurrentErrorBoundary(Component) {
  return function WrappedComponent(props) {
    return (
      <ConcurrentErrorBoundary>
        <Component {...props} />
      </ConcurrentErrorBoundary>
    );
  };
}
```

## 6. 用户体验优化

### 降级提示组件
```javascript
// components/CompatibilityNotice.js
import React, { useState, useEffect } from 'react';
import appInitializer from '../AppInitializer';

function CompatibilityNotice() {
  const [showNotice, setShowNotice] = useState(false);
  const [mode, setMode] = useState(appInitializer.renderMode);

  useEffect(() => {
    // 只在降级模式下显示提示
    if (mode !== 'concurrent') {
      setShowNotice(true);
      // 5秒后自动隐藏
      const timer = setTimeout(() => setShowNotice(false), 5000);
      return () => clearTimeout(timer);
    }
  }, [mode]);

  if (!showNotice || mode === 'concurrent') {
    return null;
  }

  const getMessage = () => {
    switch (mode) {
      case 'legacy-with-suspense':
        return '您的浏览器部分支持最新特性，应用运行在兼容模式下。';
      case 'legacy':
        return '检测到较旧的浏览器，建议升级以获得更好的体验。';
      default:
        return '';
    }
  };

  return (
    <div className="compatibility-notice">
      <div className="notice-content">
        <span className="notice-icon">ℹ️</span>
        <span className="notice-text">{getMessage()}</span>
        <button 
          className="notice-close"
          onClick={() => setShowNotice(false)}
        >
          ×
        </button>
      </div>
    </div>
  );
}

export default CompatibilityNotice;
```

### 性能监控和报告
```javascript
// utils/performanceMonitor.js
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      renderMode: appInitializer.renderMode,
      startTime: performance.now(),
      interactions: 0,
      slowRenders: 0
    };
  }

  recordInteraction(type, duration) {
    this.metrics.interactions++;
    
    if (duration > 100) { // 超过100ms认为是慢渲染
      this.metrics.slowRenders++;
    }

    // 根据模式调整阈值
    const threshold = this.getThresholdForMode();
    if (duration > threshold) {
      console.warn(`Slow ${type} in ${this.metrics.renderMode} mode:`, duration);
    }
  }

  getThresholdForMode() {
    switch (this.metrics.renderMode) {
      case 'concurrent': return 16; // 60fps
      case 'legacy-with-suspense': return 33; // 30fps
      default: return 50; // 20fps
    }
  }

  report() {
    const runtime = performance.now() - this.metrics.startTime;
    const slowRenderRate = this.metrics.slowRenders / this.metrics.interactions;
    
    return {
      ...this.metrics,
      runtime,
      slowRenderRate,
      isPerformanceGood: slowRenderRate < 0.1 // 小于10%慢渲染
    };
  }
}

export default new PerformanceMonitor();
```

## 7. 最佳实践总结

### 降级策略原则
1. **渐进增强**：从最基础的功能开始，逐步添加高级特性
2. **优雅降级**：确保核心功能在所有环境下都能正常工作
3. **透明降级**：用户应该感受不到降级的存在
4. **性能监控**：持续监控不同模式下的性能表现

### 实现checklist
```javascript
// 降级处理checklist
const compatibilityChecklist = {
  detection: {
    browserCapabilities: '✓ 检测浏览器API支持',
    reactVersion: '✓ 检测React版本',
    performanceBaseline: '✓ 建立性能基线'
  },
  
  architecture: {
    adaptiveHooks: '✓ 实现Hook适配层',
    conditionalComponents: '✓ 条件组件渲染',
    errorBoundaries: '✓ 错误边界处理'
  },
  
  performance: {
    polyfills: '✓ 必要的polyfill',
    lazyLoading: '✓ 按需加载',
    monitoring: '✓ 性能监控'
  },
  
  userExperience: {
    loadingStates: '✓ 加载状态指示',
    errorMessages: '✓ 友好的错误提示',
    compatibilityNotice: '✓ 兼容性提醒'
  }
};
```

这种降级策略确保了应用在各种浏览器环境下都能提供良好的用户体验，同时最大化利用现代浏览器的并发渲染能力。
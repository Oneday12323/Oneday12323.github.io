---
title: React 项目从打包到用户访问的完整流程
tags: React Webpack 打包 部署 CDN 缓存
article_header:
  type: cover
---
# React 项目从打包到用户访问的完整流程

## 一、流水线触发阶段

```
开发者提交代码 → Git Push → 触发 CI/CD 流水线
```

典型的触发条件：
- Push 到特定分支（如 `main`、`release`）
- 创建 Pull Request
- 手动触发构建
一般来说，更新了代码之后会进行自动化测试，测试通过后才会继续后续的构建和部署流程。

## 二、构建环境准备（talos打包工具可以配置具体的命令）

```bash
# 1. 拉取代码
git clone/pull

# 2. 安装依赖
npm install  # 或 yarn install

# 3. 读取环境变量
export APP_ENV=production
export APP_API_HOST=https://api.example.com
export PUBLIC_URL=/
```

## 三、Webpack 打包流程

### 1. **初始化阶段**
```
读取 a.config.js （包含了webpack相关的配置）
    ↓
解析 configureWebpack 配置
    ↓
初始化 Webpack Compiler
```

### 2. **编译阶段**

#### **入口处理**
```javascript
// Webpack 从入口文件开始
src/index.js (entry)
    ↓
import App from './App'
import './styles.css'
```

#### **模块解析** (resolve 配置生效)
```javascript
// 遇到 import 语句
import { api } from '@/utils/api'

// Webpack 根据 resolve.alias 解析
'@' → path.resolve(__dirname, 'src')
// 实际路径：src/utils/api.js

// 根据 resolve.extensions 自动补全
api → api.js → api.jsx → api.ts → api.tsx
```

#### **代码转译**
```javascript
// 1. TypeScript/JSX 转译
<App /> → React.createElement(App, null)

// 2. ES6+ 转 ES5 (transpileDependencies 配置的模块)
const foo = () => {} → var foo = function() {}

// 3. CSS 处理
.box { width: 375px; }
    ↓ (viewport 插件)
.box { width: 50vw; }  // 375/750 * 100
```

#### **依赖图构建**
```
index.js
  ├─ App.jsx
  │   ├─ Header.jsx
  │   ├─ Content.jsx
  │   └─ styles.css
  ├─ react (node_modules)
  ├─ axios (node_modules)
  └─ zustand (node_modules)
```

### 3. **优化阶段** (optimization 配置)

#### **代码分割** (splitChunks)
```javascript
optimization: {
  splitChunks: {
    chunks: 'all',
    name: false,
  }
}
```

**自动拆分结果：**
```
打包前：
  - 所有代码在一起 (2MB)

打包后：
  - main.[contenthash].js        (业务代码 200KB)
  - vendors-node_modules.[hash].js  (第三方库 1.5MB)
  - runtime-main.[hash].js       (Webpack runtime 10KB)
  - 0.[hash].chunk.js           (异步加载的组件)
```

#### **代码压缩** (TerserPlugin)
```javascript
// 压缩前
function calculateTotal(items) {
  const total = items.reduce((sum, item) => {
    return sum + item.price;
  }, 0);
  return total;
}

// 压缩后
function a(b){return b.reduce((c,d)=>c+d.price,0)}
```

#### **文件哈希** (contenthash)
```javascript
output: {
  filename: '[name].[contenthash:8].js'
}

// 生成结果：
main.a1b2c3d4.js
vendors.e5f6g7h8.js

// 文件内容改变 → 哈希改变 → 浏览器重新下载
// 文件内容不变 → 哈希不变 → 浏览器使用缓存
```

### 4. **资源生成阶段**

#### **HtmlWebpackPlugin 生成 HTML**
```html
<!-- public/index.html (模板) -->
<!DOCTYPE html>
<html>
<head>
  <title>My App</title>
</head>
<body>
  <div id="root"></div>
</body>
</html>

<!-- ↓ 构建后 ↓ -->

<!DOCTYPE html>
<html>
<head>
  <title>My App</title>
  <link href="/static/css/main.a1b2c3d4.css" rel="stylesheet">
</head>
<body>
  <div id="root"></div>
  <script src="/static/js/runtime-main.e5f6g7h8.js"></script>
  <script src="/static/js/vendors.i9j0k1l2.js"></script>
  <script src="/static/js/main.a1b2c3d4.js"></script>
</body>
</html>
```

### 5. **输出目录结构**
```
dist/
├── index.html
├── static/
│   ├── js/
│   │   ├── main.a1b2c3d4.js           (业务代码)
│   │   ├── runtime-main.e5f6g7h8.js   (webpack runtime)
│   │   ├── vendors-node_modules.i9j0k1l2.js  (第三方库)
│   │   └── 0.m3n4o5p6.chunk.js        (异步组件)
│   ├── css/
│   │   └── main.a1b2c3d4.css
│   └── media/
│       └── logo.q7r8s9t0.png
```

## 四、部署阶段

### 1. **上传到服务器/CDN**
```bash
# 流水线执行部署命令
aws s3 sync dist/ s3://my-bucket/  # 上传到 AWS S3
# 或
scp -r dist/* user@server:/var/www/html/  # 上传到自有服务器
```

### 2. **CDN 配置**
```
静态资源 (JS/CSS/图片) → CDN
    ↓
配置缓存策略：
  - HTML: Cache-Control: no-cache (始终验证)
  - JS/CSS: Cache-Control: max-age=31536000 (1年，因为有 hash)
```

### 3. **Nginx 配置** (针对 SPA)
```nginx
server {
  listen 80;
  server_name example.com;
  root /var/www/html;

  location / {
    try_files $uri $uri/ /index.html;  # historyApiFallback
  }

  # API 代理 (生产环境配置，对应开发环境的 devServer.proxy)
  location /servertreeapi/ {
    proxy_pass http://api-server:8080;
    proxy_set_header Host $host;
  }

  # 静态资源缓存
  location /static/ {
    expires 1y;
    add_header Cache-Control "public, immutable";
  }
}
```

## 五、用户访问流程

### 1. **首次访问**
```
用户输入 URL: https://example.com
    ↓
DNS 解析 → 服务器 IP
    ↓
请求 index.html (从服务器)
    ↓
解析 HTML，发现资源标签
    ↓
并行下载：
  - runtime-main.e5f6g7h8.js (从 CDN)
  - vendors.i9j0k1l2.js (从 CDN)
  - main.a1b2c3d4.js (从 CDN)
  - main.a1b2c3d4.css (从 CDN)
    ↓
执行 JS：
  1. Webpack runtime 初始化
  2. 加载 React 和第三方库
  3. 执行业务代码
  4. ReactDOM.render(<App />, document.getElementById('root'))
    ↓
渲染页面，用户看到内容
```

### 2. **第二次访问** (缓存生效)
```
用户再次访问 https://example.com
    ↓
请求 index.html (304 Not Modified 或重新下载，因为 no-cache)
    ↓
检查资源：
  - runtime-main.e5f6g7h8.js → 文件名未变 → 使用缓存 ✅
  - vendors.i9j0k1l2.js → 使用缓存 ✅
  - main.a1b2c3d4.js → 使用缓存 ✅
    ↓
页面秒开！只下载了 HTML (几 KB)
```

### 3. **代码更新后** (contenthash 作用)
```
开发者修改了业务代码并部署
    ↓
新的构建产物：
  - main.z9y8x7w6.js (新 hash)  ← 改变了
  - vendors.i9j0k1l2.js (hash 不变)  ← 未改变
  - runtime-main.v5u4t3s2.js (新 hash)  ← 因为包含了新的 chunk 信息
    ↓
用户访问：
  - 下载新的 index.html
  - 下载 main.z9y8x7w6.js (新文件)
  - 下载 runtime-main.v5u4t3s2.js (新文件)
  - 使用缓存 vendors.i9j0k1l2.js (hash 未变) ✅
    ↓
只下载了变化的文件，节省流量和时间
```

## 六、特殊场景处理

### 1. **按需加载** (Code Splitting)
```javascript
// 代码中使用动态 import
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// 用户首次访问时
下载：main.js, vendors.js, runtime.js
    ↓
用户点击某个按钮，触发 LazyComponent
    ↓
动态下载：0.m3n4o5p6.chunk.js
    ↓
渲染 LazyComponent
```

### 2. **API 请求** (devServer.proxy 对应的生产配置)
```javascript
// 开发环境
axios.get('/servertreeapi/user')
    ↓
devServer.proxy 转发到 process.env.APP_API_HOST

// 生产环境
axios.get('/servertreeapi/user')
    ↓
Nginx 配置的 proxy_pass 转发到实际 API 服务器
```

### 3. **路由跳转** (historyApiFallback)
```
用户访问：https://example.com/about
    ↓
Nginx 的 try_files 配置：
  1. 查找 /about 文件 → 不存在
  2. 查找 /about/ 目录 → 不存在
  3. 返回 /index.html ✅
    ↓
React Router 接管路由，渲染 About 组件
```

## 七、完整时间线总结

```
T+0s    : 开发者 git push
T+10s   : CI/CD 流水线启动
T+20s   : npm install 完成
T+30s   : Webpack 开始编译
T+120s  : 打包完成，生成 dist/ 目录
T+130s  : 上传到服务器/CDN
T+140s  : 部署完成，新版本上线

用户访问：
T+0ms   : 用户输入 URL
T+50ms  : DNS 解析完成
T+200ms : HTML 下载完成
T+500ms : JS/CSS 下载完成
T+800ms : React 渲染完成
T+1000ms: 用户看到页面 🎉
```

这就是从代码提交到用户看到页面的完整流程。每个环节都有对应的优化点，比如缓存策略、代码分割、CDN 加速等。
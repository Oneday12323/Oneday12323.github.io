---
title: 无重复子串长度
tags: 算法 滑动窗口 哈希表
article_header:
  type: cover
---

``` ts
function lengthOfLongestSubstring(s: string): number {
    // record 
    const map = new Map();
    const strArr = s.split('');
    const n = strArr.length;

    let left = 0;
    let right = 0;
    let maxlen = 0;
    let currentLen = 0;

    while(right < n) {
        if (map.has(strArr[right])) {
            const temp = map.get(strArr[right]);
            if (temp >= left) {
                left = temp + 1;
            }
        }

        map.set(strArr[right], right);

        currentLen = right - left + 1;
        maxlen = Math.max(maxlen, currentLen);
        right++;
    }

    return maxlen;
};
```

## 解题思路：
> “滑动窗口 + 哈希表记录最后位置”

1. 核心目标：找到最长无重复子串长度。
- 用 left、right 表示当前窗口 [left, right]，窗口内不允许重复。
- 用 map 记录每个字符最后一次出现的位置。

2. 流程：

- 右指针 right 从左到右扫描。
- 如果当前字符 s[right] 在 map 中存在，取到它上次位置 pos = map.get(s[right])。若 pos >= left，说明重复字符在窗口内，必须把 left 移到 pos + 1，保证窗口内无重复。
- 无论是否重复，都要更新 map 为当前字符最新位置。
- 每一步计算当前窗口长度 right - left + 1，更新最大值。
- right++ 继续扩大窗口。

3. 这种写法的关键点：
- left 只会向右移动，不回退，整体 O(n)。
- map 保证我们可以跳跃式移动左边界，而不是一格格收缩。
> React 18 Concurrent Rendering 详解

## 什么是Concurrent Rendering

Concurrent Rendering（并发渲染）是React 18引入的一种新的渲染模式，它允许React在渲染过程中暂停、恢复或放弃工作，从而让浏览器有机会处理其他任务，保持应用的响应性。

## 核心问题：为什么需要并发渲染？

**传统同步渲染的问题：**
在React 17及之前版本中，一旦开始渲染，整个过程是同步且不可中断的。如果组件树很大或计算很复杂，会导致：
- 主线程被长时间占用
- 用户交互（点击、输入）被阻塞
- 动画卡顿
- 页面无响应

**并发渲染的解决方案：**
通过时间切片（Time Slicing）技术，将渲染工作分解成小块，在每个时间片之间让出控制权给浏览器，处理用户交互和其他高优先级任务。

## 工作原理

### 1. Fiber架构基础
并发渲染建立在React的Fiber架构之上：
- 每个组件对应一个Fiber节点
- Fiber节点包含组件信息、状态、副作用等
- 形成一个可遍历、可中断的工作单元链表

### 2. 优先级调度
React使用优先级系统来决定哪些更新应该优先处理：

```javascript
// 优先级示例（从高到低）
1. Sync Priority - 同步优先级（用户交互）
2. InputContinuous Priority - 连续输入
3. Default Priority - 默认优先级
4. Transition Priority - 过渡优先级
5. Idle Priority - 空闲优先级
```

### 3. 时间切片机制
```javascript
// 简化的时间切片概念
function workLoop() {
  while (workInProgress && !shouldYield()) {
    // 处理一个工作单元
    workInProgress = performUnitOfWork(workInProgress);
  }
  
  if (workInProgress) {
    // 还有工作要做，安排下次继续
    scheduleWork();
  }
}

function shouldYield() {
  // 检查是否超过时间片（通常是5ms）
  return getCurrentTime() >= deadline;
}
```

## 关键特性和API

### 1. startTransition
将更新标记为非紧急，允许被更高优先级的更新中断：

```javascript
import { startTransition } from 'react';

function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleSearch = (newQuery) => {
    // 紧急更新：立即更新输入框
    setQuery(newQuery);
    
    // 非紧急更新：可以被中断
    startTransition(() => {
      const searchResults = expensiveSearch(newQuery);
      setResults(searchResults);
    });
  };

  return (
    <div>
      <input value={query} onChange={e => handleSearch(e.target.value)} />
      <SearchResultsList results={results} />
    </div>
  );
}
```

### 2. useTransition Hook
提供编程式控制和pending状态：

```javascript
import { useTransition } from 'react';

function App() {
  const [isPending, startTransition] = useTransition();
  const [tab, setTab] = useState('home');

  const handleTabChange = (newTab) => {
    startTransition(() => {
      setTab(newTab);
    });
  };

  return (
    <div>
      <TabButton 
        onClick={() => handleTabChange('profile')}
        disabled={isPending}
      >
        Profile {isPending && <Spinner />}
      </TabButton>
      <TabContent tab={tab} />
    </div>
  );
}
```

### 3. useDeferredValue
延迟更新值，直到更紧急的更新完成：

```javascript
import { useDeferredValue, useMemo } from 'react';

function ProductList({ query }) {
  const deferredQuery = useDeferredValue(query);
  
  const filteredProducts = useMemo(() => {
    // 只有当没有更紧急的更新时才重新计算
    return products.filter(product => 
      product.name.includes(deferredQuery)
    );
  }, [deferredQuery]);

  return (
    <div>
      {filteredProducts.map(product => (
        <ProductItem key={product.id} product={product} />
      ))}
    </div>
  );
}
```

### 4. Suspense边界
处理异步组件和数据获取：

```javascript
function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <ProfilePage />
    </Suspense>
  );
}

function ProfilePage() {
  const profile = use(fetchProfile()); // React 18+ 的数据获取
  return <div>{profile.name}</div>;
}
```

## 实际应用场景

### 1. 搜索界面优化
```javascript
function SearchApp() {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition();
  
  const handleInputChange = (e) => {
    const value = e.target.value;
    setQuery(value); // 立即更新输入框
    
    startTransition(() => {
      // 延迟搜索结果更新
      performSearch(value);
    });
  };

  return (
    <div>
      <input 
        value={query} 
        onChange={handleInputChange}
        className={isPending ? 'loading' : ''}
      />
      <SearchResults query={query} />
    </div>
  );
}
```

### 2. 大列表渲染
```javascript
function BigList({ items }) {
  const [filter, setFilter] = useState('');
  const deferredFilter = useDeferredValue(filter);
  
  const filteredItems = useMemo(() => {
    return items.filter(item => 
      item.name.toLowerCase().includes(deferredFilter.toLowerCase())
    );
  }, [items, deferredFilter]);

  return (
    <div>
      <input 
        value={filter}
        onChange={e => setFilter(e.target.value)}
        placeholder="Filter items..."
      />
      <VirtualizedList items={filteredItems} />
    </div>
  );
}
```

## 性能对比

**React 17 同步渲染：**
```
用户输入 → 阻塞渲染(100ms) → 更新完成 → 响应下次输入
```

**React 18 并发渲染：**
```
用户输入 → 立即响应 → 后台渲染(分片) → 更新完成
```

## 注意事项和最佳实践

### 1. 不是所有更新都需要并发
```javascript
// 紧急更新：用户交互
setInputValue(newValue);

// 非紧急更新：数据展示
startTransition(() => {
  setSearchResults(results);
});
```

### 2. 避免过度使用
```javascript
// ❌ 不必要的transition
startTransition(() => {
  setSimpleCounter(count + 1);
});

// ✅ 适当的使用场景
startTransition(() => {
  setLargeDataSet(expensiveCalculation());
});
```

### 3. 处理pending状态
```javascript
function Component() {
  const [isPending, startTransition] = useTransition();
  
  return (
    <div>
      <button disabled={isPending}>
        {isPending ? 'Loading...' : 'Update'}
      </button>
    </div>
  );
}
```

## 总结

Concurrent Rendering是React 18的核心创新，它通过：
- **时间切片**：将渲染工作分解成小块
- **优先级调度**：优先处理用户交互
- **可中断渲染**：让出控制权给浏览器
- **智能批处理**：自动合并更新

从而实现了更好的用户体验，特别是在处理大量数据、复杂UI更新时，能够保持应用的响应性和流畅性。
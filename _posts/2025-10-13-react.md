---
title: React-高频输入性能优化完整指南
tags: React 性能优化 防抖 节流 useDeferredValue startTransition 虚拟滚动
article_header:
  type: cover
---
## 一、问题分析

### 典型的高频输入场景

```jsx
// ❌ 性能问题示例
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    
    // 问题1: 每次输入都触发昂贵的搜索
    const filtered = hugeDataset.filter(item => 
      item.name.includes(value)
    );
    setResults(filtered);
    
    // 问题2: 可能触发网络请求
    fetch(`/api/search?q=${value}`)
      .then(res => res.json())
      .then(data => setResults(data));
  };
  
  return (
    <>
      <input value={query} onChange={handleChange} />
      {/* 问题3: 渲染大量列表项 */}
      <ul>
        {results.map(item => (
          <HeavyListItem key={item.id} item={item} />
        ))}
      </ul>
    </>
  );
}
```

**性能瓶颈：**
1. 每次按键都触发复杂计算
2. 频繁的网络请求
3. 大量 DOM 更新
4. 组件频繁重新渲染

## 二、防抖（Debounce）

### 1. 基础防抖实现

```jsx
import { useState, useCallback } from 'react';

function useDebounce(callback, delay) {
  const [timeoutId, setTimeoutId] = useState(null);
  
  const debouncedCallback = useCallback((...args) => {
    // 清除之前的定时器
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    
    // 设置新的定时器
    const newTimeoutId = setTimeout(() => {
      callback(...args);
    }, delay);
    
    setTimeoutId(newTimeoutId);
  }, [callback, delay, timeoutId]);
  
  return debouncedCallback;
}

// 使用
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const search = useCallback((value) => {
    const filtered = hugeDataset.filter(item => 
      item.name.toLowerCase().includes(value.toLowerCase())
    );
    setResults(filtered);
  }, []);
  
  const debouncedSearch = useDebounce(search, 300);
  
  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value); // 立即更新输入框
    debouncedSearch(value); // 延迟搜索
  };
  
  return (
    <>
      <input value={query} onChange={handleChange} />
      <ResultList items={results} />
    </>
  );
}
```

### 2. 使用 useRef 优化

```jsx
import { useRef, useCallback } from 'react';

function useDebounce(callback, delay) {
  const timeoutRef = useRef(null);
  
  const debouncedCallback = useCallback((...args) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    
    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]);
  
  // 清理函数
  const cancel = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
  }, []);
  
  return [debouncedCallback, cancel];
}

// 使用
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const search = useCallback((value) => {
    setResults(hugeDataset.filter(item => 
      item.name.includes(value)
    ));
  }, []);
  
  const [debouncedSearch, cancelSearch] = useDebounce(search, 300);
  
  useEffect(() => {
    // 组件卸载时取消防抖
    return () => cancelSearch();
  }, [cancelSearch]);
  
  return (
    <>
      <input 
        value={query} 
        onChange={(e) => {
          setQuery(e.target.value);
          debouncedSearch(e.target.value);
        }}
      />
      <ResultList items={results} />
    </>
  );
}
```

### 3. 使用 lodash 的 debounce

```jsx
import { useMemo } from 'react';
import debounce from 'lodash/debounce';

function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  // 使用 useMemo 确保 debounce 函数只创建一次
  const debouncedSearch = useMemo(
    () => debounce((value) => {
      setResults(hugeDataset.filter(item => 
        item.name.includes(value)
      ));
    }, 300),
    [] // 空依赖，只创建一次
  );
  
  // 组件卸载时取消
  useEffect(() => {
    return () => {
      debouncedSearch.cancel();
    };
  }, [debouncedSearch]);
  
  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };
  
  return (
    <>
      <input value={query} onChange={handleChange} />
      <ResultList items={results} />
    </>
  );
}
```

## 三、节流（Throttle）

### 1. 基础节流实现

```jsx
function useThrottle(callback, delay) {
  const lastRunRef = useRef(Date.now());
  const timeoutRef = useRef(null);
  
  const throttledCallback = useCallback((...args) => {
    const now = Date.now();
    const timeSinceLastRun = now - lastRunRef.current;
    
    if (timeSinceLastRun >= delay) {
      // 立即执行
      callback(...args);
      lastRunRef.current = now;
    } else {
      // 设置定时器，确保最后一次调用也会执行
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      
      timeoutRef.current = setTimeout(() => {
        callback(...args);
        lastRunRef.current = Date.now();
      }, delay - timeSinceLastRun);
    }
  }, [callback, delay]);
  
  return throttledCallback;
}

// 使用
function ScrollHandler() {
  const [scrollPos, setScrollPos] = useState(0);
  
  const handleScroll = useCallback(() => {
    setScrollPos(window.scrollY);
    // 执行其他昂贵操作
  }, []);
  
  const throttledScroll = useThrottle(handleScroll, 200);
  
  useEffect(() => {
    window.addEventListener('scroll', throttledScroll);
    return () => window.removeEventListener('scroll', throttledScroll);
  }, [throttledScroll]);
  
  return <div>Scroll Position: {scrollPos}</div>;
}
```

### 2. Debounce vs Throttle

```jsx
// 场景对比
function Demo() {
  const [debounceValue, setDebounceValue] = useState('');
  const [throttleValue, setThrottleValue] = useState('');
  
  const debouncedSet = useMemo(
    () => debounce((val) => setDebounceValue(val), 300),
    []
  );
  
  const throttledSet = useMemo(
    () => throttle((val) => setThrottleValue(val), 300),
    []
  );
  
  return (
    <div>
      <input onChange={(e) => {
        debouncedSet(e.target.value);
        throttledSet(e.target.value);
      }} />
      
      {/* 
        用户快速输入 "hello" (每个字符间隔 100ms)
        
        Debounce: 
        - 输入过程中：不更新
        - 停止输入 300ms 后：显示 "hello"
        - 总更新次数：1 次
        
        Throttle:
        - t=0ms: 'h' (立即)
        - t=300ms: 'hel'
        - t=600ms: 'hello'
        - 总更新次数：3 次
      */}
      
      <p>Debounce: {debounceValue}</p>
      <p>Throttle: {throttleValue}</p>
    </div>
  );
}
```

## 四、使用 useDeferredValue

```jsx
import { useState, useDeferredValue, useMemo } from 'react';

function SearchBox() {
  const [query, setQuery] = useState('');
  
  // 延迟更新的值
  const deferredQuery = useDeferredValue(query);
  
  // 基于延迟值计算结果
  const results = useMemo(() => {
    return hugeDataset.filter(item => 
      item.name.toLowerCase().includes(deferredQuery.toLowerCase())
    );
  }, [deferredQuery]);
  
  return (
    <div>
      {/* 输入框立即响应 */}
      <input 
        value={query} 
        onChange={(e) => setQuery(e.target.value)}
        placeholder="搜索..."
      />
      
      {/* 列表延迟更新 */}
      <ResultList items={results} />
    </div>
  );
}

// 优化：添加加载提示
function SearchBoxWithIndicator() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  
  // 检测是否正在延迟
  const isStale = query !== deferredQuery;
  
  const results = useMemo(() => 
    hugeDataset.filter(item => 
      item.name.includes(deferredQuery)
    ),
    [deferredQuery]
  );
  
  return (
    <div>
      <input 
        value={query} 
        onChange={(e) => setQuery(e.target.value)}
      />
      
      {/* 显示加载状态 */}
      <div style={{ opacity: isStale ? 0.5 : 1 }}>
        {isStale && <span>更新中...</span>}
        <ResultList items={results} />
      </div>
    </div>
  );
}
```

## 五、使用 startTransition

```jsx
import { useState, useTransition } from 'react';

function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    const value = e.target.value;
    
    // 高优先级：立即更新输入框
    setQuery(value);
    
    // 低优先级：延迟更新搜索结果
    startTransition(() => {
      const filtered = hugeDataset.filter(item => 
        item.name.includes(value)
      );
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input 
        value={query} 
        onChange={handleChange}
        disabled={isPending}
      />
      
      {isPending ? (
        <LoadingSkeleton />
      ) : (
        <ResultList items={results} />
      )}
    </div>
  );
}
```

## 六、虚拟滚动（Virtual Scrolling）

```jsx
import { useCallback, useState } from 'react';
import { FixedSizeList } from 'react-window';

function VirtualizedList({ items }) {
  const Row = useCallback(({ index, style }) => (
    <div style={style}>
      <ListItem item={items[index]} />
    </div>
  ), [items]);
  
  return (
    <FixedSizeList
      height={600}        // 可见区域高度
      itemCount={items.length}
      itemSize={50}       // 每项高度
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}

// 完整示例
function SearchWithVirtualScroll() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const debouncedSearch = useMemo(
    () => debounce((value) => {
      const filtered = hugeDataset.filter(item => 
        item.name.includes(value)
      );
      setResults(filtered);
    }, 300),
    []
  );
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => {
          setQuery(e.target.value);
          debouncedSearch(e.target.value);
        }}
      />
      
      {/* 只渲染可见区域的项目 */}
      <VirtualizedList items={results} />
    </div>
  );
}
```

## 七、优化网络请求

### 1. 请求防抖 + 取消

```jsx
function useSearchAPI(query) {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const abortControllerRef = useRef(null);
  
  useEffect(() => {
    if (!query) {
      setResults([]);
      return;
    }
    
    // 取消之前的请求
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    // 创建新的 AbortController
    abortControllerRef.current = new AbortController();
    
    const fetchResults = async () => {
      setLoading(true);
      
      try {
        const response = await fetch(
          `/api/search?q=${encodeURIComponent(query)}`,
          { signal: abortControllerRef.current.signal }
        );
        
        const data = await response.json();
        setResults(data);
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Search failed:', error);
        }
      } finally {
        setLoading(false);
      }
    };
    
    // 防抖
    const timeoutId = setTimeout(fetchResults, 300);
    
    return () => {
      clearTimeout(timeoutId);
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [query]);
  
  return { results, loading };
}

// 使用
function SearchBox() {
  const [query, setQuery] = useState('');
  const { results, loading } = useSearchAPI(query);
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      
      {loading && <Spinner />}
      <ResultList items={results} />
    </div>
  );
}
```

### 2. 使用 SWR 或 React Query

```jsx
import useSWR from 'swr';

function useSearchWithSWR(query) {
  const { data, error, isLoading } = useSWR(
    query ? `/api/search?q=${query}` : null,
    fetcher,
    {
      dedupingInterval: 300, // 300ms 内相同请求去重
      revalidateOnFocus: false,
    }
  );
  
  return {
    results: data?.results || [],
    loading: isLoading,
    error
  };
}

// 使用
function SearchBox() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const { results, loading } = useSearchWithSWR(deferredQuery);
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      
      {loading && <Spinner />}
      <ResultList items={results} />
    </div>
  );
}
```

## 八、组件级优化

### 1. memo 优化

```jsx
import { memo } from 'react';

// ❌ 每次父组件渲染都会重新渲染
function ListItem({ item }) {
  console.log('Rendering:', item.name);
  return <div>{item.name}</div>;
}

// ✅ 只在 item 变化时重新渲染
const ListItem = memo(function ListItem({ item }) {
  console.log('Rendering:', item.name);
  return <div>{item.name}</div>;
});

// 自定义比较函数
const ListItem = memo(
  function ListItem({ item, highlight }) {
    return (
      <div style={{ background: highlight ? 'yellow' : 'white' }}>
        {item.name}
      </div>
    );
  },
  (prevProps, nextProps) => {
    // 返回 true 表示不需要重新渲染
    return (
      prevProps.item.id === nextProps.item.id &&
      prevProps.highlight === nextProps.highlight
    );
  }
);
```

### 2. 使用 key 优化列表

```jsx
// ❌ 使用索引作为 key
function BadList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item.name}</li>
      ))}
    </ul>
  );
}

// ✅ 使用唯一 ID 作为 key
function GoodList({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

### 3. 分页加载

```jsx
function PaginatedList({ items }) {
  const [page, setPage] = useState(1);
  const itemsPerPage = 50;
  
  const paginatedItems = useMemo(() => {
    const start = (page - 1) * itemsPerPage;
    return items.slice(start, start + itemsPerPage);
  }, [items, page]);
  
  const totalPages = Math.ceil(items.length / itemsPerPage);
  
  return (
    <div>
      <ul>
        {paginatedItems.map(item => (
          <ListItem key={item.id} item={item} />
        ))}
      </ul>
      
      <Pagination 
        current={page}
        total={totalPages}
        onChange={setPage}
      />
    </div>
  );
}
```

## 九、综合最佳实践方案

```jsx
import { useState, useMemo, useTransition, memo, useCallback } from 'react';
import { FixedSizeList } from 'react-window';
import debounce from 'lodash/debounce';

// 1. 优化的列表项组件
const ListItem = memo(({ item, style }) => {
  return (
    <div style={style} className="list-item">
      <h3>{item.name}</h3>
      <p>{item.description}</p>
    </div>
  );
});

// 2. 主搜索组件
function OptimizedSearch({ data }) {
  const [rawQuery, setRawQuery] = useState('');
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition();
  
  // 3. 防抖处理
  const debouncedSetQuery = useMemo(
    () => debounce((value) => {
      startTransition(() => {
        setQuery(value);
      });
    }, 300),
    []
  );
  
  // 4. 过滤和排序（使用 useMemo 缓存）
  const filteredData = useMemo(() => {
    if (!query) return data;
    
    const lowerQuery = query.toLowerCase();
    return data.filter(item => 
      item.name.toLowerCase().includes(lowerQuery) ||
      item.description.toLowerCase().includes(lowerQuery)
    );
  }, [data, query]);
  
  // 5. 处理输入
  const handleChange = useCallback((e) => {
    const value = e.target.value;
    setRawQuery(value); // 立即更新输入框
    debouncedSetQuery(value); // 延迟更新搜索
  }, [debouncedSetQuery]);
  
  // 6. 清理
  useEffect(() => {
    return () => debouncedSetQuery.cancel();
  }, [debouncedSetQuery]);
  
  // 7. 虚拟滚动渲染函数
  const Row = useCallback(({ index, style }) => (
    <ListItem item={filteredData[index]} style={style} />
  ), [filteredData]);
  
  return (
    <div className="search-container">
      {/* 搜索框 */}
      <input
        type="text"
        value={rawQuery}
        onChange={handleChange}
        placeholder="搜索..."
        className="search-input"
      />
      
      {/* 结果统计 */}
      <div className="search-stats">
        找到 {filteredData.length} 条结果
        {isPending && <span className="loading">更新中...</span>}
      </div>
      
      {/* 虚拟滚动列表 */}
      <div style={{ opacity: isPending ? 0.6 : 1 }}>
        {filteredData.length > 0 ? (
          <FixedSizeList
            height={600}
            itemCount={filteredData.length}
            itemSize={80}
            width="100%"
          >
            {Row}
          </FixedSizeList>
        ) : (
          <div className="no-results">没有找到结果</div>
        )}
      </div>
    </div>
  );
}

export default OptimizedSearch;
```

## 十、性能对比总结

| 优化方案 | 适用场景 | 优点 | 缺点 |
|---------|---------|------|------|
| **Debounce** | 搜索框、API 请求 | 减少执行次数 | 有延迟感 |
| **Throttle** | 滚动、拖拽 | 保持周期性更新 | 仍会频繁执行 |
| **useDeferredValue** | 本地搜索、过滤 | 原生支持，可中断 | React 18+ |
| **startTransition** | 大量 DOM 更新 | 保持 UI 响应 | 需要手动标记 |
| **虚拟滚动** | 长列表 | 极大减少 DOM 节点 | 实现复杂 |
| **memo** | 复杂组件 | 避免不必要渲染 | 浅比较开销 |
| **分页** | 超大数据集 | 减少渲染数量 | 用户体验较差 |

## 十一、推荐组合方案

```jsx
// 小数据量 (< 1000 项)
// → Debounce + useMemo
function SmallDataSearch() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 300);
  
  const results = useMemo(() => 
    data.filter(item => item.name.includes(debouncedQuery)),
    [debouncedQuery]
  );
  
  return <List items={results} />;
}

// 中等数据量 (1000-10000 项)
// → Debounce + startTransition + memo
function MediumDataSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const debouncedSearch = useMemo(
    () => debounce((value) => {
      startTransition(() => {
        setResults(data.filter(item => item.name.includes(value)));
      });
    }, 300),
    []
  );
  
  return <MemoizedList items={results} isPending={isPending} />;
}

// 大数据量 (> 10000 项)
// → Debounce + Virtual Scrolling + Web Worker
function LargeDataSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const workerRef = useRef(null);
  
  useEffect(() => {
    workerRef.current = new Worker('search-worker.js');
    
    workerRef.current.onmessage = (e) => {
      setResults(e.data);
    };
    
    return () => workerRef.current.terminate();
  }, []);
  
  const debouncedSearch = useMemo(
    () => debounce((value) => {
      workerRef.current.postMessage({ query: value, data });
    }, 300),
    []
  );
  
  return <VirtualList items={results} />;
}
```
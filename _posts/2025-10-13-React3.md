---
title: React 中断与恢复机制详解
tags: React 性能优化 中断 恢复 Fiber
article_header:
  type: cover
excerpt_separator: <!--more-->
---
## 一、核心概念：不恢复，而是重新开始

首先需要澄清一个重要概念：**React 在中断后不会恢复之前的渲染状态，而是丢弃未完成的工作，从头开始重新渲染。**
<!--more-->
### 为什么不恢复？


```jsx
function Example() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);
  
  const handleChange = (e) => {
    setInput(e.target.value);
    
    startTransition(() => {
      // 假设这个计算很耗时
      setList(filterAndSort(data, e.target.value));
    });
  };
}

// 场景：
// t=0ms: 用户输入 'a'
// t=5ms: 开始渲染 filterAndSort(data, 'a')，处理到 50%
// t=10ms: 用户输入 'ab'（新的更高优先级更新）
// 
// 问题：如果继续之前 50% 的工作
// → 结果会基于旧的 input='a'
// → 但最新的 input='ab'
// → UI 会不一致！
//
// 解决：丢弃 50% 的工作，重新计算 filterAndSort(data, 'ab')
```

## 二、状态保存机制

虽然 React 不恢复渲染进度，但会保存一些关键信息：

### 1. Root 节点的状态

```javascript
class FiberRootNode {
  constructor() {
    // 当前显示的 Fiber 树
    this.current = null;
    
    // 待处理的优先级车道
    this.pendingLanes = 0b0000000;
    
    // 挂起的 lanes（被中断的）
    this.suspendedLanes = 0b0000000;
    
    // 已过期的 lanes（必须同步执行）
    this.expiredLanes = 0b0000000;
    
    // 正在进行的 lanes
    this.pingedLanes = 0b0000000;
    
    // 每个 lane 的过期时间
    this.expirationTimes = [NoTimestamp, ...];
    
    // 回调节点
    this.callbackNode = null;
    this.callbackPriority = NoLane;
  }
}
```

### 2. 双缓冲机制

```javascript
// Current 树 - 当前屏幕上显示的
const currentTree = {
  tag: 'div',
  memoizedState: { count: 0 },  // 已提交的状态
  memoizedProps: { className: 'container' },
  child: {...}
};

// WorkInProgress 树 - 正在构建的
const wipTree = {
  tag: 'div',
  memoizedState: { count: 1 },  // 正在计算的新状态
  pendingProps: { className: 'container active' },
  alternate: currentTree,  // 指向 current 树
  child: {...}
};

// current 树也指向 workInProgress 树
currentTree.alternate = wipTree;
```

### 3. Update 队列保存

```javascript
class UpdateQueue {
  constructor() {
    // 基础状态（上次提交的状态）
    this.baseState = null;
    
    // 基础更新队列（被跳过的低优先级更新）
    this.firstBaseUpdate = null;
    this.lastBaseUpdate = null;
    
    // 待处理的更新队列
    this.shared = {
      pending: null  // 环形链表
    };
  }
}

// Update 对象
class Update {
  constructor() {
    this.lane = NoLane;        // 优先级
    this.tag = UpdateState;    // 更新类型
    this.payload = null;       // 新状态或函数
    this.callback = null;      // 回调
    this.next = null;          // 下一个更新
  }
}
```

## 三、中断发生时的处理

### 1. 完整的中断流程

```javascript
// ============ 渲染循环 ============
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function performConcurrentWorkOnRoot(root) {
  // 1. 获取要渲染的 lanes
  const lanes = getNextLanes(root, NoLanes);
  
  if (lanes === NoLanes) {
    return null;
  }
  
  // 2. 开始渲染
  let exitStatus = renderRootConcurrent(root, lanes);
  
  // 3. 检查退出状态
  if (exitStatus === RootInProgress) {
    // ====== 被中断了！======
    
    // 3.1 保存中断信息
    // workInProgress 已经自动保存在全局变量中
    // pendingLanes 已经包含了未完成的 lanes
    
    // 3.2 检查是否有更高优先级的工作
    const nextLanes = getNextLanes(root, NoLanes);
    
    if (nextLanes !== NoLanes && nextLanes !== lanes) {
      // 有更高优先级的工作
      // 当前工作会被自动中断
      // 返回一个函数，让调度器继续调度
      return performConcurrentWorkOnRoot.bind(null, root);
    }
  }
  
  if (exitStatus === RootCompleted) {
    // 4. 完成渲染
    const finishedWork = root.current.alternate;
    root.finishedWork = finishedWork;
    root.finishedLanes = lanes;
    
    // 5. 提交更新
    commitRoot(root);
  }
  
  // 6. 继续调度
  ensureRootIsScheduled(root);
  
  return null;
}
```

### 2. renderRootConcurrent 详解

```javascript
function renderRootConcurrent(root, lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  
  // ====== 关键：准备新的工作栈 ======
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // 不同的 root 或不同的 lanes，需要重新开始
    prepareFreshStack(root, lanes);
  }
  
  // 开始工作循环
  do {
    try {
      workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  
  // 重置执行上下文
  executionContext = prevExecutionContext;
  
  // 检查完成状态
  if (workInProgress !== null) {
    // 还有未完成的工作（被中断）
    return RootInProgress;
  } else {
    // 工作完成
    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes;
    return workInProgressRootExitStatus;
  }
}
```

### 3. prepareFreshStack - 准备新的工作栈

```javascript
function prepareFreshStack(root, lanes) {
  // 1. 清空之前的工作
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  
  // 2. 取消之前的超时
  const timeoutHandle = root.timeoutHandle;
  if (timeoutHandle !== noTimeout) {
    root.timeoutHandle = noTimeout;
    cancelTimeout(timeoutHandle);
  }
  
  // 3. 如果有未完成的工作，中断它
  if (workInProgress !== null) {
    let interruptedWork = workInProgress.return;
    while (interruptedWork !== null) {
      // 清理未完成的 fiber 节点
      unwindInterruptedWork(interruptedWork);
      interruptedWork = interruptedWork.return;
    }
  }
  
  // 4. 创建新的 workInProgress 树
  workInProgressRoot = root;
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressRootExitStatus = RootInProgress;
}
```

### 4. createWorkInProgress - 创建工作树

```javascript
function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  
  if (workInProgress === null) {
    // ====== 首次渲染：创建新的 fiber ======
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode
    );
    
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    
    // 建立双向连接
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // ====== 后续渲染：复用已有的 fiber ======
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    
    // 清除副作用
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }
  
  // ====== 复制状态（关键！）======
  // 从 current 复制已提交的状态
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.dependencies = current.dependencies;
  workInProgress.lanes = current.lanes;
  workInProgress.childLanes = current.childLanes;
  workInProgress.sibling = current.sibling;
  
  return workInProgress;
}
```

## 四、Update 队列的处理

### 1. Update 如何保存

```javascript
// 用户触发多次 setState
function handleMultipleUpdates() {
  // 第 1 次更新
  setCount(1);  // 创建 update1, lane = DefaultLane
  
  // 第 2 次更新
  startTransition(() => {
    setCount(2);  // 创建 update2, lane = TransitionLane
  });
  
  // 第 3 次更新
  setCount(3);  // 创建 update3, lane = DefaultLane
}

// Update 队列结构（环形链表）
const updateQueue = {
  baseState: 0,  // 基础状态
  firstBaseUpdate: null,
  lastBaseUpdate: null,
  shared: {
    pending: update3  // 指向最后一个 update
  }
};

// 环形链表
update3.next = update1;
update1.next = update2;
update2.next = update3;

/*
    update3 ←─────┐
      ↓           │
    update1       │
      ↓           │
    update2 ──────┘
*/
```

### 2. 处理 Update 队列

```javascript
function processUpdateQueue(workInProgress, props, instance, renderLanes) {
  const queue = workInProgress.updateQueue;
  
  // 1. 复制共享的待处理更新
  let firstBaseUpdate = queue.firstBaseUpdate;
  let lastBaseUpdate = queue.lastBaseUpdate;
  let pendingQueue = queue.shared.pending;
  
  if (pendingQueue !== null) {
    queue.shared.pending = null;
    
    // 断开环形链表
    const lastPendingUpdate = pendingQueue;
    const firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    
    // 添加到 base 队列
    if (lastBaseUpdate === null) {
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }
    lastBaseUpdate = lastPendingUpdate;
  }
  
  // 2. 处理更新
  if (firstBaseUpdate !== null) {
    let newState = queue.baseState;
    let newLanes = NoLanes;
    let newBaseState = null;
    let newFirstBaseUpdate = null;
    let newLastBaseUpdate = null;
    
    let update = firstBaseUpdate;
    do {
      const updateLane = update.lane;
      
      // ====== 关键：检查优先级 ======
      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // 优先级不够，跳过这个更新
        const clone = {
          lane: updateLane,
          tag: update.tag,
          payload: update.payload,
          callback: update.callback,
          next: null
        };
        
        // ====== 保存被跳过的更新 ======
        if (newLastBaseUpdate === null) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          // 保存跳过前的状态
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        
        // 标记需要后续处理
        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        // 优先级足够，处理这个更新
        
        // ====== 关键：如果之前有跳过的更新 ======
        if (newLastBaseUpdate !== null) {
          // 必须也克隆这个更新，保持顺序
          const clone = {
            lane: NoLane,  // 已处理，移除 lane
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        
        // 计算新状态
        newState = getStateFromUpdate(
          workInProgress,
          queue,
          update,
          newState,
          props,
          instance
        );
      }
      
      update = update.next;
      if (update === null) {
        break;
      }
    } while (true);
    
    // 3. 保存结果
    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }
    
    queue.baseState = newBaseState;
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate;
    
    workInProgress.lanes = newLanes;
    workInProgress.memoizedState = newState;
  }
}
```

### 3. 示例：Update 队列处理

```javascript
// 场景
function Component() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    setCount(1);  // Update1: lane=DefaultLane
    
    startTransition(() => {
      setCount(c => c + 10);  // Update2: lane=TransitionLane
    });
    
    setCount(c => c + 100);  // Update3: lane=DefaultLane
  };
}

// ====== 第 1 次渲染：renderLanes = DefaultLane ======

// 初始状态
baseState = 0;
updates = [Update1, Update2, Update3];

// 处理过程
Update1: lane=DefaultLane
  → isSubsetOfLanes(DefaultLane, DefaultLane) = true
  → 处理: newState = 1

Update2: lane=TransitionLane  
  → isSubsetOfLanes(DefaultLane, TransitionLane) = false
  → 跳过: 保存到 baseQueue
  → newBaseState = 1 (跳过前的状态)

Update3: lane=DefaultLane
  → isSubsetOfLanes(DefaultLane, DefaultLane) = true
  → 之前有跳过的更新，也要保存到 baseQueue
  → 处理: newState = 1 + 100 = 101

// 结果
memoizedState = 101  // 渲染 101
baseState = 1        // 保存跳过前的状态
baseQueue = [Update2(clone), Update3(clone)]  // 保存被跳过的更新

// ====== 第 2 次渲染：renderLanes = TransitionLane ======

// 初始状态
baseState = 1;  // 从上次保存的开始
updates = [Update2, Update3];  // 从 baseQueue 开始

// 处理过程
Update2: lane=TransitionLane
  → 处理: newState = 1 + 10 = 11

Update3: lane=NoLane (已处理过，移除了 lane)
  → 处理: newState = 11 + 100 = 111

// 结果
memoizedState = 111  // 最终状态
baseState = 111
baseQueue = null
```

## 五、完整的中断恢复案例

```javascript
// 用户快速输入的完整过程

function SearchBox() {
  const [input, setInput] = useState('');
  const [results, setResults] = useState([]);
  
  const search = (query) => {
    // 假设需要 20ms
    return expensiveSearch(query);
  };
  
  const handleChange = (e) => {
    const value = e.target.value;
    setInput(value);
    
    startTransition(() => {
      setResults(search(value));
    });
  };
}

// ============ 时间线 ============

// t=0ms: 用户输入 'r'
// ────────────────────────────────
// 创建两个更新:
updates = [
  { lane: DefaultLane, payload: 'r' },           // input
  { lane: TransitionLane, payload: search('r') } // results
];

root.pendingLanes = DefaultLane | TransitionLane;
// = 0b00010000 | 0b01000000 = 0b01010000

ensureRootIsScheduled(root);

// t=1ms: 调度器选择 DefaultLane
// ────────────────────────────────
renderLanes = getNextLanes(root) = DefaultLane;

prepareFreshStack(root, DefaultLane);
// → 创建新的 workInProgress 树
// → workInProgress = root
// → workInProgressRootRenderLanes = DefaultLane

workLoopConcurrent();
// → 处理 input fiber
// → 跳过 results fiber (优先级不够)

// t=2ms: 提交 DefaultLane
// ────────────────────────────────
commitRoot(root);
// → input 显示 'r'
// → pendingLanes = TransitionLane (移除 DefaultLane)

// t=3ms: 调度器选择 TransitionLane
// ────────────────────────────────
renderLanes = TransitionLane;

prepareFreshStack(root, TransitionLane);
// → 创建新的 workInProgress 树
// → workInProgress = root

workLoopConcurrent();
deadline = 3 + 5 = 8ms;

// → t=3ms: 处理 results fiber
// → t=4ms: 执行 search('r'), 处理中...
// → t=5ms: search('r') 继续...
// → t=6ms: search('r') 继续...
// → t=7ms: search('r') 继续...

// t=8ms: 用户输入 'e' ⚡
// ────────────────────────────────
// 创建新的更新:
updates = [
  { lane: DefaultLane, payload: 're' },
  { lane: TransitionLane, payload: search('re') }
];

root.pendingLanes |= DefaultLane | TransitionLane;
ensureRootIsScheduled(root);

// t=8ms: workLoopConcurrent 中
// ────────────────────────────────
workLoopConcurrent() {
  // search('r') 还在执行...
  
  shouldYield() {
    // 检查时间
    getCurrentTime() >= deadline  // 8 >= 8, true!
    
    // 检查优先级
    nextLanes = getNextLanes(root);  // DefaultLane
    currentLane = workInProgressRootRenderLanes;  // TransitionLane
    
    hasHigherPriorityWork = (DefaultLane < TransitionLane);  // true!
    
    return true;  // ⚠️ 中断！
  }
}

// ====== 中断处理 ======
renderRootConcurrent 返回 RootInProgress;

// workInProgress 保持在当前位置
// 但会被下次 prepareFreshStack 清除

// pendingLanes 仍然包含 TransitionLane
root.pendingLanes = DefaultLane | TransitionLane;

// t=9ms: 处理高优先级更新
// ────────────────────────────────
renderLanes = DefaultLane;

prepareFreshStack(root, DefaultLane);
// ⚠️ 清除之前的工作
// → unwindInterruptedWork(workInProgress)
// → workInProgress = createWorkInProgress(root.current)
// → 丢弃 search('r') 的所有进度

workLoopConcurrent();
// → 处理 input fiber
// → input 显示 're'

commitRoot(root);

// t=11ms: 重新处理 TransitionLane
// ────────────────────────────────
renderLanes = TransitionLane;

prepareFreshStack(root, TransitionLane);
// → 再次创建新的 workInProgress 树
// → 从头开始！

workLoopConcurrent();
// → 执行 search('re')  // ⚠️ 注意：不是 search('r')
// → 基于最新的 input='re'

// t=31ms: 完成并提交
commitRoot(root);
// → results 显示 search('re') 的结果
```

## 六、总结

### 关键点

1. **不恢复，而是重新开始**
   - 保证基于最新数据计算
   - 避免 UI 不一致

2. **保存的内容**
   - `pendingLanes`: 待处理的优先级
   - `baseState`: 跳过更新前的状态
   - `baseQueue`: 被跳过的低优先级更新
   - `updateQueue`: 所有更新的完整记录

3. **双缓冲机制**
   - `current` 树: 已提交的状态
   - `workInProgress` 树: 正在计算的状态
   - 通过 `alternate` 互相引用

4. **Update 队列处理**
   - 环形链表保存所有更新
   - 按优先级过滤处理
   - 被跳过的更新保存到 baseQueue
   - 下次渲染时从 baseState 和 baseQueue 开始

5. **中断是廉价的**
   - 只是丢弃内存中的计算
   - 没有副作用需要回滚
   - 重新计算保证正确性